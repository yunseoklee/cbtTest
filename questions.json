[
  {
    "id": "A3",
    "회차": "1회차 (Sample A) - 복원됨",
    "chapter": "1.3.1",
    "k_level": "K2",
    "question": "다음 중 테스팅 원리인 ‘완벽한 테스팅은 불가능하다(Testing shows the presence of defects, not their absence)’는 원리를 따르는 테스터의 행동으로 가장 적절한 것은?",
    "options": [
      "a. 결함이 없음을 증명하기 위해 모든 실행 경로를 커버하는 테스트 케이스를 설계한다",
      "b. 테스팅의 목적이 결함이 없음을 증명하는 것이 아님을 팀에 교육한다",
      "c. 테스트 케이스 수를 줄이기 위해 동등 분할 및 경계값 분석과 같은 기법을 사용한다",
      "d. 테스팅을 리스크 기반으로 수행하여 테스팅 노력을 우선순위가 높은 영역에 집중한다"
    ],
    "correct_answer": "d",
    "explanation": "이 원리는 '테스팅이 모든 결함의 부재를 증명할 수 없다'는 것과 '모든 것을 테스트하는 것은 불가능하다'는 두 가지 의미를 모두 내포합니다. 완벽한 테스팅이 불가능하므로, 리스크 기반으로 테스팅 노력을 집중하는 것이 가장 현실적이고 효율적인 대처 방법입니다. (FL-1.3.1 K2)"
  },
  {
    "id": "A4",
    "회차": "1회차 (Sample A) - 복원됨",
    "chapter": "1.4.1",
    "k_level": "K2",
    "question": "다음 중 **테스트 설계 활동**은?",
    "options": [
      "a. 테스트 노력을 추정한다",
      "b. 테스트 케이스를 설계한다",
      "c. 커버리지 아이템을 도출한다",
      "d. 결함을 보고한다"
    ],
    "correct_answer": "c",
    "explanation": "테스트 설계 활동은 테스트 컨디션(테스트 대상)을 커버하는 테스트 케이스를 설계하고, 이 테스트 케이스가 커버할 항목(**커버리지 아이템**)을 도출하는 활동을 포함합니다. (FL-1.4.1 K2)"
  },
  {
    "id": "A11",
    "회차": "1회차 (Sample A) - 복원됨",
    "chapter": "2.2.1",
    "k_level": "K2",
    "question": "다음 중 **단위 테스팅(Component Testing)**의 주요 목적은?",
    "options": [
      "a. 사용자 요구사항의 엔드-투-엔드 시나리오를 검증한다",
      "b. 개발된 컴포넌트의 기능적 및 비기능적 품질을 평가한다",
      "c. 컴포넌트 간 인터페이스에서 발생하는 결함을 찾는다",
      "d. 비즈니스 요구사항에 대한 시스템의 준비 상태를 확인한다"
    ],
    "correct_answer": "b",
    "explanation": "단위 테스팅은 개별적으로 테스트 가능한 가장 작은 컴포넌트에서 수행되며, 주로 개발자에 의해 수행됩니다. 이 레벨의 주요 목적은 컴포넌트의 기능적 및 비기능적 품질 특성을 평가하는 것입니다. (FL-2.2.1 K2)"
  },
  {
    "id": "A12",
    "회차": "1회차 (Sample A) - 복원됨",
    "chapter": "2.2.1",
    "k_level": "K2",
    "question": "다음 중 **통합 테스팅(Integration Testing)**에 대한 설명으로 가장 올바른 것은?",
    "options": [
      "a. 컴포넌트 간의 상호작용 및 인터페이스에 중점을 둔다",
      "b. 주로 최종 사용자 환경에서 실행된다",
      "c. 시스템 요구사항 명세서에 대한 적합성을 평가한다",
      "d. 일반적으로 인수 테스팅 이후에 수행된다"
    ],
    "correct_answer": "a",
    "explanation": "통합 테스팅은 개별 컴포넌트들이 결합되어 상호작용하는 방식을 테스트하며, 초점은 컴포넌트 간의 **인터페이스** 및 **상호작용**에 있는 결함을 발견하는 것입니다. (FL-2.2.1 K2)"
  },
  {
    "id": "A13",
    "회차": "1회차 (Sample A) - 복원됨",
    "chapter": "2.2.3",
    "k_level": "K2",
    "question": "이전 버전에서 수정되지 않은 기능에 대해 다시 테스트를 수행하는 **회귀 테스팅(Regression Testing)**의 주된 목적은?",
    "options": [
      "a. 테스트 환경이 올바르게 설정되었는지 확인한다",
      "b. 새로운 기능이 올바르게 작동하는지 확인한다",
      "c. 변경사항으로 인해 기존 기능에 부작용이 발생하지 않았는지 확인한다",
      "d. 기존 결함이 올바르게 수정되었는지 확인한다"
    ],
    "correct_answer": "c",
    "explanation": "회귀 테스팅은 소프트웨어의 변경(결함 수정, 새로운 기능 추가, 환경 변경 등)이 이전에 올바르게 작동했던 영역에 부작용(예기치 않은 결함)을 일으키지 않았는지 확인하는 데 중점을 둡니다. (FL-2.2.3 K2)"
  },
  {
    "id": "A14",
    "회차": "1회차 (Sample A) - 복원됨",
    "chapter": "3.1.2",
    "k_level": "K2",
    "question": "다음 중 **정적 테스팅(Static Testing)**의 주요 이점은?",
    "options": [
      "a. 코드 실행 중 발생하는 결함을 발견한다",
      "b. 개발 프로세스 후반부에 결함을 발견하여 수정 비용을 절감한다",
      "c. 동적 테스팅으로 발견하기 어려운 **결함을 조기에** 그리고 **더 저렴하게** 발견한다",
      "d. 사용자 경험을 평가하여 사용성 관련 결함을 식별한다"
    ],
    "correct_answer": "c",
    "explanation": "정적 테스팅(리뷰, 정적 분석)은 코드 실행 없이 초기 작업 산출물에서 결함을 발견하여, 개발 프로세스 초기에 결함을 수정할 수 있게 함으로써 비용을 절감합니다. (FL-3.1.2 K2)"
  },
  {
    "id": "A15",
    "회차": "1회차 (Sample A) - 복원됨",
    "chapter": "3.2.3",
    "k_level": "K2",
    "question": "다음 중 **리뷰 리더(Review Leader)**의 책임은?",
    "options": [
      "a. 검토 중 결함을 식별하고 보고서를 작성한다",
      "b. 검토 대상 작업 산출물을 작성한다",
      "c. 리뷰 프로세스의 전반적인 관리 및 성공적인 완료를 책임진다",
      "d. 발견된 결함을 수정하고 재검토가 필요한 경우 재검토에 참여한다"
    ],
    "correct_answer": "c",
    "explanation": "리뷰 리더는 리뷰 프로세스를 계획, 시작, 관리하고, 필요한 경우 후속 조치를 보장하는 등 리뷰 프로세스의 전반적인 성공을 책임집니다. (FL-3.2.3 K2)"
  },
  {
    "id": "A17",
    "회차": "1회차 (Sample A) - 복원됨",
    "chapter": "4.2.1",
    "k_level": "K3",
    "question": "주어진 시나리오(특정 유효/무효 입력값)에서 동등 분할 기법을 적용하여 도출된 최소 테스트 케이스 수는?",
    "options": [
      "a. 3개",
      "b. 4개",
      "c. 5개",
      "d. 6개"
    ],
    "correct_answer": "c",
    "explanation": "동등 분할(Equivalence Partitioning)은 각 동등 클래스(유효 및 무효)당 최소 하나의 테스트 케이스를 선택합니다. 문제의 시나리오 분석 결과, 5개의 유효/무효 동등 클래스가 존재하여 최소 5개의 테스트 케이스가 필요합니다. (FL-4.2.1 K3)"
  },
  {
    "id": "A18",
    "회차": "1회차 (Sample A) - 복원됨",
    "chapter": "4.2.2",
    "k_level": "K3",
    "question": "주어진 시나리오(특정 숫자 범위)에서 **경계값 분석(BVA)** 기법을 적용하여 도출된 테스트 케이스의 경계값은?",
    "options": [
      "a. 1, 10, 100",
      "b. 0, 1, 100, 101",
      "c. 1, 10, 101",
      "d. 0, 10, 100"
    ],
    "correct_answer": "b",
    "explanation": "경계값 분석(BVA)은 정의된 경계(boundary) 바로 위, 경계, 그리고 경계 바로 아래 값(N-1, N, N+1)을 테스트합니다. 주어진 범위가 '1부터 100'이라면, 테스트 케이스는 **0, 1, 100, 101**이 됩니다. (FL-4.2.2 K3)"
  },
  {
    "id": "A20",
    "회차": "1회차 (Sample A) - 복원됨",
    "chapter": "4.2.4",
    "k_level": "K3",
    "question": "주어진 시나리오(시스템의 상태 및 전환)에서 **상태 전이 테스팅(State Transition Testing)**을 적용하여 가장 중요한 테스트 케이스는?",
    "options": [
      "a. 가능한 모든 입력값을 조합한다",
      "b. 시스템의 모든 상태를 테스트한다",
      "c. 모든 가능한 유효/무효 전환을 테스트한다",
      "d. 커버리지를 달성하기 위해 최소한의 경로를 선택한다"
    ],
    "correct_answer": "c",
    "explanation": "상태 전이 테스팅의 주요 목적은 시스템의 상태와 상태 간의 모든 가능한 유효 및 무효 **전환(Transition)**을 테스트하는 것입니다. (FL-4.2.4 K3)"
  },
  {
    "id": "A22",
    "회차": "1회차 (Sample A) - 복원됨",
    "chapter": "5.2.1",
    "k_level": "K2",
    "question": "리스크 분석 중에 팀은 다음과 같은 리스크를 고려했다: “시스템이 고객에게 너무 높은 할인을 허용할 수 있다.” 팀은 리스크 영향도가 매우 높을 것으로 추정했다.\n이 경우, 리스크 발생 가능성에 대해서는 어떻게 말할 수 있는가?",
    "options": [
      "a. 리스크 가능성도 매우 높다. 리스크 영향도가 높다는 건 리스크 발생 가능성도 항상 높다는 걸 의미한다",
      "b. 매우 낮다. 리스크 영향도가 높다는 건 리스크 발생 가능성은 항상 낮다는 걸 뜻한다",
      "c. 리스크 영향도와 리스크 발생 가능성은 독립적이기 때문에 리스크 발생 가능성에 대해 말할 수 없다",
      "d. 이렇게 리스크 영향도가 높은 경우 리스크 발생 가능성은 중요하지 않기 때문에 정의 할 필요가 없다"
    ],
    "correct_answer": "c",
    "explanation": "리스크는 **영향도(Impact)**와 **발생 가능성(Likelihood)**이라는 두 가지 독립적인 요소로 구성됩니다. 한 요소의 높고 낮음이 다른 요소의 높고 낮음을 결정하지 않습니다. 따라서 영향도가 높더라도 발생 가능성은 알 수 없습니다. (FL-5.2.1 K2)"
  },
  {
    "id": "A23",
    "회차": "1회차 (Sample A) - 복원됨",
    "chapter": "5.2.2",
    "k_level": "K2",
    "question": "다음은 개발할 새로운 소프트웨어 제품과 관련해 식별한 리스크이다:\ni. 관리자가 숙련된 테스터 두 명을 다른 프로젝트로 이동시킨다\nii. 시스템이 기능 안전 표준을 준수하지 않는다\niii. 시스템 응답 시간이 사용자 요구사항보다 느리다\niv. 이해관계자의 기대치가 부정확하다\nv. 장애인이 시스템을 사용할 때 문제가 발생한다\n\n다음 중 **프로젝트 리스크**는?",
    "options": [
      "a. i, iv",
      "b. iv, v",
      "c. i, iii",
      "d. ii, v"
    ],
    "correct_answer": "a",
    "explanation": "**프로젝트 리스크**는 프로젝트의 목표 달성에 영향을 미치는 리스크입니다 (i: 자원 부족, iv: 요구사항 또는 범위 문제). **제품 리스크**는 개발되는 시스템의 품질에 영향을 미칩니다 (ii, iii, v). (FL-5.2.2 K2)"
  },
  {
    "id": "A24",
    "회차": "1회차 (Sample A) - 복원됨",
    "chapter": "5.2.3",
    "k_level": "K2",
    "question": "다음 중 **리스크 기반 테스팅**의 이점을 가장 잘 보여주는 것은?",
    "options": [
      "a. 모든 리스크를 식별하고 완화하여 테스트를 완벽하게 만든다",
      "b. 리스크 분석 결과를 사용하여 테스트할 영역을 결정한다",
      "c. 리스크 수준에 관계없이 모든 영역에 동일한 테스트 노력을 할당한다",
      "d. 리스크가 높은 영역에 더 많은 테스트 노력을 집중할 수 있다"
    ],
    "correct_answer": "d",
    "explanation": "리스크 기반 테스팅의 주요 이점은 식별된 리스크의 수준에 따라 테스트 노력을 차별적으로 분배하여, 리스크가 높은 영역에 리소스를 집중할 수 있다는 점입니다. (FL-5.2.3 K2)"
  },
  {
    "id": "A27",
    "회차": "1회차 (Sample A) - 복원됨",
    "chapter": "5.3.3",
    "k_level": "K2",
    "question": "다음 중 **테스트 모니터링 및 제어**에 대한 설명으로 올바른 것은?",
    "options": [
      "a. 테스트 제어 활동은 테스트 모니터링 활동과 독립적으로 수행된다",
      "b. 테스트 제어는 계획된 목표와 실제 진행 상황 간의 편차를 줄이는 데 중점을 둔다",
      "c. 테스트 모니터링은 테스트 활동의 진행 상황에 대한 피드백을 수집한다",
      "d. 테스트 제어는 테스트 모니터링의 일부로 간주될 수 있다"
    ],
    "correct_answer": "b",
    "explanation": "테스트 모니터링(진행 상황 측정)에서 수집된 정보를 기반으로 **테스트 제어**(목표 달성을 위한 조치)를 수행합니다. 테스트 제어는 계획된 목표와 실제 진행 상황 간의 편차를 줄이는 데 중점을 둡니다. (FL-5.3.3 K2)"
  },
  {
    "id": "A28",
    "회차": "1회차 (Sample A) - 복원됨",
    "chapter": "5.4.1",
    "k_level": "K2",
    "question": "다음 중 **결함 보고서**의 주요 목적은?",
    "options": [
      "a. 결함의 근본 원인 분석",
      "b. 결함이 발견된 작업 산출물을 식별",
      "c. 개발자가 결함을 **재현**하고 **수정**할 수 있도록 정보를 제공",
      "d. 테스트 팀의 성과를 측정"
    ],
    "correct_answer": "c",
    "explanation": "결함 보고서의 가장 주된 목적은 개발자가 결함을 재현하고, 이해하고, 수정하는 데 필요한 충분한 정보를 제공하는 것입니다. (FL-5.4.1 K2)"
  },
  {
    "id": "A30",
    "회차": "1회차 (Sample A) - 복원됨",
    "chapter": "5.5.1",
    "k_level": "K2",
    "question": "테스트 완료 보고서에 포함되어야 하는 정보가 **아닌** 것은?",
    "options": [
      "a. 발생한 이벤트(예: 테스트 실행 중에 발생한 문제)에 대한 요약",
      "b. 발견된 결함 수와 심각도 분석",
      "c. 테스트 활동 시작 전에 수행되는 활동",
      "d. 테스트웨어의 유지보수 및 재사용 가능성에 대한 분석"
    ],
    "correct_answer": "c",
    "explanation": "테스트 완료 보고서는 **테스트 활동이 완료된 후** 작성되며, 테스트 활동 **시작 전**에 수행되는 활동(예: 계획)은 포함하지 않습니다. (FL-5.5.1 K2)"
  },
  {
    "id": "A32",
    "회차": "1회차 (Sample A) - 복원됨",
    "chapter": "6.1.1",
    "k_level": "K2",
    "question": "테스팅 도구를 선택할 때의 주요 고려사항은?",
    "options": [
      "a. 도구가 모든 결함을 자동으로 발견하는지 여부",
      "b. 도구가 기존 개발 프로세스 및 도구와 통합될 수 있는지 여부",
      "c. 도구가 테스트 팀의 모든 수동적인 노력을 제거하는지 여부",
      "d. 도구의 구매 비용이 가장 낮은지 여부"
    ],
    "correct_answer": "b",
    "explanation": "테스팅 도구를 선택할 때 가장 중요한 고려사항 중 하나는 도구가 기존 환경 및 프로세스에 통합되어 원활하게 작동할 수 있는지 여부입니다. (FL-6.1.1 K2)"
  },
  {
    "id": "A34",
    "회차": "1회차 (Sample A) - 복원됨",
    "chapter": "6.2.1",
    "k_level": "K2",
    "question": "다음 중 **성능 테스팅 도구**의 주요 기능은?",
    "options": [
      "a. 테스트 케이스 설계 자동화",
      "b. 시스템에 대량의 부하(Load) 및 스트레스(Stress)를 시뮬레이션",
      "c. 테스트 관리 활동 지원",
      "d. 정적 분석 수행"
    ],
    "correct_answer": "b",
    "explanation": "성능 테스팅 도구는 시스템의 응답 시간, 처리량 등을 측정하기 위해 시스템에 대량의 부하 및 스트레스를 시뮬레이션하는 기능을 제공합니다. (FL-6.2.1 K2)"
  },
  {
    "id": "A35",
    "회차": "1회차 (Sample A) - 복원됨",
    "chapter": "6.2.2",
    "k_level": "K2",
    "question": "테스팅 도구 사용의 잠재적 이점이 **아닌** 것은?",
    "options": [
      "a. 반복적인 작업을 자동화하여 일관성 및 효율성 향상",
      "b. 수동 테스팅으로 불가능한 테스트 유형(예: 성능) 수행 가능",
      "c. 테스트 관리 활동을 완전히 제거하여 비용 절감",
      "d. 테스트 실행 및 결과 비교의 정확도 향상"
    ],
    "correct_answer": "c",
    "explanation": "테스팅 도구는 테스트 활동을 **지원**할 뿐, 테스트 관리 활동(계획, 제어 등)을 완전히 제거할 수는 없습니다. (FL-6.2.2 K2)"
  },
  {
    "id": "A36",
    "회차": "1회차 (Sample A) - 복원됨",
    "chapter": "6.2.2",
    "k_level": "K2",
    "question": "다음 중 테스팅 도구 도입 및 사용 시 발생할 수 있는 주요 **위험(Risk)**은?",
    "options": [
      "a. 테스트 프로세스가 너무 공식화되어 유연성이 떨어진다",
      "b. 도구 사용을 위한 학습 및 훈련에 대한 노력이 과소평가된다",
      "c. 도구가 모든 결함을 발견할 것이라는 비현실적인 기대를 갖는다",
      "d. 도구가 기존의 테스트 프로세스와 통합되지 않는다"
    ],
    "correct_answer": "b",
    "explanation": "테스트 도구를 성공적으로 도입하는 데 있어 가장 흔한 위험 중 하나는 도구 사용을 위한 초기 학습 곡선과 유지보수 노력을 과소평가하는 것입니다. (FL-6.2.2 K2)"
  },
  {
    "id": "A39",
    "회차": "1회차 (Sample A) - 복원됨",
    "chapter": "6.2.3",
    "k_level": "K2",
    "question": "테스팅 도구의 성공적인 도입을 위한 **성공 요소**가 아닌 것은?",
    "options": [
      "a. 테스터가 도구 사용에 필요한 기술을 습득할 수 있도록 교육을 제공한다",
      "b. 도구 사용을 지원하기 위한 내부 전문성을 확보한다",
      "c. 도구를 모든 테스트 활동에 사용하도록 의무화한다",
      "d. 초기에는 작은 범위에서 점진적으로 도구의 사용을 확장한다"
    ],
    "correct_answer": "c",
    "explanation": "도구를 모든 테스트 활동에 의무적으로 사용하도록 강제하는 것은 유연성을 떨어뜨리고 비효율을 낳을 수 있습니다. 성공적인 도입을 위해서는 유연성을 유지하고 점진적으로 도입하는 것이 중요합니다. (FL-6.2.3 K2)"
  },
  {
    "id": "A40",
    "회차": "1회차 (Sample A) - 복원됨",
    "chapter": "6.2.3",
    "k_level": "K2",
    "question": "테스팅 도구의 성공적인 도입에 영향을 미치는 **조직적 요인**은?",
    "options": [
      "a. 도구가 특정 테스트 케이스를 자동으로 생성할 수 있는지 여부",
      "b. 테스트 조직이 도구의 유지보수를 전담할 수 있는 인력을 확보하는지 여부",
      "c. 도구의 성능이 시스템의 응답 시간을 측정할 만큼 빠른지 여부",
      "d. 도구가 다양한 플랫폼을 지원하는지 여부"
    ],
    "correct_answer": "b",
    "explanation": "조직적 요인은 도구를 지원하고 유지보수할 수 있는 인적/기술적 자원의 확보와 관련이 있습니다. **테스트 조직이 도구의 유지보수를 전담할 수 있는 인력을 확보**하는 것이 조직적 성공에 중요합니다. (FL-6.2.3 K2)"
  },
  {
    "id": "B1",
    "회차": "2회차 (Sample B) - 복원됨",
    "chapter": "1.2.1",
    "k_level": "K2",
    "question": "다음 중 테스팅이 필요한 이유인 것은?",
    "options": [
      "a. 동적 테스팅에서는 사용자가 절대 할 수 없는 방법으로 테스트 대상에 문제를 발생시켜 품질을 향상시킨다",
      "b. 정적 테스팅은 개발자가 동적 테스팅보다 더 빠른 시점에 작성한 코드에서 장애를 식별 하기 위해 사용한다",
      "c. 정적 분석은 출력이 없는 시스템 컴포넌트가 배포 준비 완료 상태라는 증거를 고객에게 제공한다",
      "d. 리뷰를 통해 요구사항 명세서의 품질이 높아짐에 따라 도출되는 작업 산출물의 변경 필요성이 줄어들게 된다"
    ],
    "correct_answer": "d",
    "explanation": "리뷰와 같은 정적 테스팅은 결함을 조기에 발견하고 작업 산출물의 품질을 높이는 데 기여하며, 결과적으로 개발 단계에서 결함이 줄어들어 변경 필요성이 감소합니다. 이는 테스팅의 주요 목적 중 하나인 품질 개선과 관련이 있습니다."
  },
  {
    "id": "B2",
    "회차": "2회차 (Sample B) - 복원됨",
    "chapter": "1.2.2",
    "k_level": "K2",
    "question": "다음 중 품질 보증(QA) 및 품질 제어(QC)에 대한 설명으로 올바른 것은?",
    "options": [
      "a. 품질 보증은 테스팅의 일부로 수행된다",
      "b. 구문 테스팅은 품질 제어의 일부로 수행된다",
      "c. 테스팅과 품질 제어는 같은 의미이다",
      "d. 테스팅은 품질 보증의 일부로 수행된다"
    ],
    "correct_answer": "b",
    "explanation": "테스팅은 **품질 제어(QC)** 활동의 일부이며, 제품 자체에 초점을 맞춥니다. 품질 보증(QA)은 오류와 결함을 **방지**하기 위해 예방적 접근 방식을 사용해 프로세스 개선에 중점을 둡니다. 따라서 구문 테스팅(테스팅 활동)은 품질 제어의 일부입니다."
  },
  {
    "id": "B3",
    "회차": "2회차 (Sample B) - 복원됨",
    "chapter": "1.3.1",
    "k_level": "K2",
    "question": "'테스팅 원리' 중 하나는 완벽한 테스팅은 불가능하다는 것이다. 다음 중 이 원리에 대처할 수 있는 방법은?",
    "options": [
      "a. 명시된 모든 가능한 출력값을 커버하는 테스트 케이스 작성",
      "b. 가능한 모든 테스트 입력값을 문서화하고 중요도에 따라 우선순위 지정",
      "c. 리뷰 및 다른 정적 테스팅 접근법을 통해 가능한 한 빨리 테스팅 시작",
      "d. 동등 분할과 경계값 분석을 사용해 테스트 케이스 작성"
    ],
    "correct_answer": "d",
    "explanation": "'완벽한 테스팅은 불가능하다'는 원리는 모든 가능한 입력값의 조합을 테스트하는 것이 불가능하다는 사실과 관련이 있습니다. 이 원리에 대처하기 위해 동등 분할 및 경계값 분석과 같은 테스트 기법을 사용하여 테스트 케이스의 표본을 효율적으로 추출하고 테스트 노력을 집중합니다."
  },
  {
    "id": "B16",
    "회차": "2회차 (Sample B) - 복원됨",
    "chapter": "3.2.1",
    "k_level": "K1",
    "question": "다음 중 가장 공식적인 리뷰 유형은?",
    "options": [
      "a. 비공식적 리뷰",
      "b. 워크스루",
      "c. 인스펙션",
      "d. 기술적 리뷰"
    ],
    "correct_answer": "c",
    "explanation": "인스펙션(Inspection)은 리뷰 유형 중 가장 공식적이며, 명확하게 정의된 역할, 체크리스트, 측정 기준(메트릭)을 사용하여 엄격하게 구조화된 프로세스를 따릅니다. (FL-3.2.1 K1)"
  },
  {
    "id": "B17",
    "회차": "2회차 (Sample B) - 복원됨",
    "chapter": "3.2.2",
    "k_level": "K2",
    "question": "다음 중 리뷰 활동의 목적이 아닌 것은?",
    "options": [
      "a. 결함 발견 및 수정",
      "b. 프로젝트 일정과 테스트 노력을 예측하기 위한 메트릭 수집",
      "c. 검토 대상 작업 산출물의 품질 평가",
      "d. 테스트 실행 환경 구축을 완료하는 것"
    ],
    "correct_answer": "d",
    "explanation": "테스트 실행 환경 구축은 테스트 구현 또는 테스트 완료 활동에 속하며, 정적 테스팅인 리뷰의 목적이 아닙니다. 리뷰의 주요 목적은 결함 발견, 품질 향상, 메트릭 수집 등입니다. (FL-3.2.2 K2)"
  },
  {
    "id": "B19",
    "회차": "2회차 (Sample B) - 복원됨",
    "chapter": "4.1.1",
    "k_level": "K2",
    "question": "다음 중 블랙박스 테스트 기법의 특징으로 올바른 것은?",
    "options": [
      "a. 결정 테이블 테스팅은 화이트박스 테스트 기법이다.",
      "b. 테스트 케이스는 소스 코드에 있는 프로그램 구조를 분석해서 도출된다.",
      "c. 경험 기반 테스팅은 테스트 대상 시스템의 내부 구조를 활용한다.",
      "d. 테스트 케이스가 요구사항 명세서와 같은 테스트 베이스에서 도출된다."
    ],
    "correct_answer": "d",
    "explanation": "블랙박스(명세 기반) 테스트 기법은 테스트 대상의 내부 구조를 고려하지 않고, 요구사항 명세서와 같은 테스트 베이스에서 테스트 케이스를 도출합니다. (FL-4.1.1 K2)"
  },
  {
    "id": "B20",
    "회차": "2회차 (Sample B) - 복원됨",
    "chapter": "4.2.1",
    "k_level": "K3",
    "question": "주어진 시나리오(특정 유효/무효 입력값)에서 동등 분할 기법을 적용하여 도출된 최소 테스트 케이스 수는?",
    "options": [
      "a. 3개",
      "b. 4개",
      "c. 5개",
      "d. 6개"
    ],
    "correct_answer": "a",
    "explanation": "동등 분할은 각 동등 클래스(유효 및 무효)당 최소 한 개의 테스트 케이스를 도출합니다. 시나리오 분석 결과, 3개의 동등 클래스(예: 유효, 무효1, 무효2)가 존재하여 최소 3개의 테스트 케이스가 필요합니다. (FL-4.2.1 K3)"
  },
  {
    "id": "B21",
    "회차": "2회차 (Sample B) - 복원됨",
    "chapter": "4.2.2",
    "k_level": "K3",
    "question": "주어진 시나리오(특정 숫자 범위)에서 경계값 분석(BVA) 기법을 적용하여 도출된 테스트 케이스의 경계값은?",
    "options": [
      "a. 0, 10, 100",
      "b. 1, 10, 101",
      "c. 0, 1, 99, 100",
      "d. 0, 1, 100, 101"
    ],
    "correct_answer": "d",
    "explanation": "일반적으로 경계값 분석은 경계값 자체(1, 100)와 그 경계의 안쪽/바깥쪽 값(0, 101)을 사용합니다. 주어진 범위가 '1부터 100'이라면, 테스트 케이스는 경계값인 1, 100과 경계의 바깥쪽 값인 0, 101이 됩니다. (FL-4.2.2 K3)"
  },
  {
    "id": "B22",
    "회차": "2회차 (Sample B) - 복원됨",
    "chapter": "4.2.3",
    "k_level": "K3",
    "question": "주어진 비즈니스 규칙(조건과 동작)에 대해 결정 테이블 테스팅을 적용하여 도출된 최소 규칙(Rule)의 수는?",
    "options": [
      "a. 2개",
      "b. 3개",
      "c. 4개",
      "d. 6개"
    ],
    "correct_answer": "b",
    "explanation": "결정 테이블은 모든 조건의 가능한 조합과 이에 따른 동작을 규칙(Rule)으로 정리합니다. 문제의 시나리오 분석 결과, 독립적인 규칙의 최소 개수는 3개입니다. (FL-4.2.3 K3)"
  },
  {
    "id": "B30",
    "회차": "2회차 (Sample B) - 복원됨",
    "chapter": "5.1.3",
    "k_level": "K2",
    "question": "다음 중 테스트 구현 활동에 포함되는 것은?",
    "options": [
      "a. 테스트 데이터 준비",
      "b. 테스트 환경 구축 계획",
      "c. 테스트 케이스 도출",
      "d. 테스트 노력을 추정"
    ],
    "correct_answer": "a",
    "explanation": "테스트 구현 활동은 테스트 설계에서 도출된 테스트 케이스를 실행할 수 있는 형태로 만드는 것입니다. 여기에는 테스트 절차(스크립트) 작성, **테스트 데이터 준비**, 테스트 스위트 구성이 포함됩니다. (FL-5.1.3 K2)"
  },
  {
    "id": "B31",
    "회차": "2회차 (Sample B) - 복원됨",
    "chapter": "5.1.4",
    "k_level": "K3",
    "question": "주어진 테스트 실행 로그를 보고, 결함이 발생할 가능성이 가장 높은 컴포넌트는?",
    "options": [
      "a. 사용자 인터페이스 (UI)",
      "b. 데이터베이스 인터페이스",
      "c. 비즈니스 로직",
      "d. 보안 모듈"
    ],
    "correct_answer": "b",
    "explanation": "테스트 실행 로그의 실패 원인을 분석하여, DB에 저장된 데이터를 가져오는 과정에서 오류가 발생했을 가능성을 고려했을 때, 데이터베이스 인터페이스에 문제가 있을 가능성이 높습니다. (FL-5.1.4 K3)"
  },
  {
    "id": "B32",
    "회차": "2회차 (Sample B) - 복원됨",
    "chapter": "5.1.5",
    "k_level": "K3",
    "question": "다음 중 **테스트 종료 조건(Exit Criteria)**의 예시가 아닌 것은?",
    "options": [
      "a. 요구되는 모든 테스트 케이스가 통과했다",
      "b. 모든 테스트 환경이 준비되었다",
      "c. 남아 있는 알려진 결함의 심각도가 낮다",
      "d. 측정된 리스크가 허용 가능한 수준이다"
    ],
    "correct_answer": "b",
    "explanation": "테스트 환경 준비는 테스트를 시작하기 위한 **진입 조건(Entry Criteria)**에 해당합니다. 테스트 종료 조건은 '테스트를 중지할 수 있는 시점'을 정의하는 기준입니다. (FL-5.1.5 K3)"
  },
  {
    "id": "B34",
    "회차": "2회차 (Sample B) - 복원됨",
    "chapter": "5.2.4",
    "k_level": "K2",
    "question": "리스크 기반 테스팅(RBT)을 수행할 때의 주요 이점은?",
    "options": [
      "a. 테스팅에 필요한 모든 리소스를 확보할 수 있다.",
      "b. 모든 잠재적 결함을 제거할 수 있다.",
      "c. 가장 중요한 기능에 테스팅 노력을 집중할 수 있다.",
      "d. 테스트 실행 환경이 자동으로 구축된다."
    ],
    "correct_answer": "c",
    "explanation": "리스크 기반 테스팅은 제품 리스크 수준이 높은 영역에 테스트 활동을 집중함으로써, 비즈니스에 가장 큰 영향을 미칠 수 있는 결함을 먼저 찾고 중요한 기능의 품질을 보장하는 데 도움이 됩니다. (FL-5.2.4 K2)"
  },
  {
    "id": "B35",
    "회차": "2회차 (Sample B) - 복원됨",
    "chapter": "5.3.1",
    "k_level": "K2",
    "question": "다음 중 **제품 품질 메트릭**의 예시는?",
    "options": [
      "a. 평균 고장 시간(MTBF)",
      "b. 발견된 결함의 수",
      "c. 테스트 케이스 설계 시간",
      "d. 테스트 환경 구축 시간"
    ],
    "correct_answer": "a",
    "explanation": "**제품 품질 메트릭**은 테스트 대상 시스템의 품질 특성을 측정하며, 평균 고장 시간(MTBF)은 안정성을 나타내는 대표적인 품질 메트릭입니다. (FL-5.3.1 K2)"
  },
  {
    "id": "B37",
    "회차": "2회차 (Sample B) - 복원됨",
    "chapter": "5.4.1",
    "k_level": "K2",
    "question": "결함 보고서의 주요 목적은?",
    "options": [
      "a. 개발자가 결함을 **재현**하고 **수정**할 수 있도록 정보를 제공한다",
      "b. 결함의 근본 원인을 분석한다",
      "c. 테스트 팀의 성과를 측정한다",
      "d. 결함 보고서의 심각도를 변경한다"
    ],
    "correct_answer": "a",
    "explanation": "결함 보고서의 가장 주된 목적은 개발자가 결함을 재현하고, 이해하고, 수정하는 데 필요한 충분한 정보를 제공하는 것입니다. (FL-5.4.1 K2)"
  },
  {
    "id": "B40",
    "회차": "2회차 (Sample B) - 복원됨",
    "chapter": "6.2.1",
    "k_level": "K1",
    "question": "다음 중 테스팅 도구의 주요 이점은?",
    "options": [
      "a. 반복적인 작업을 자동화하여 일관성과 효율성을 높인다.",
      "b. 테스팅의 모든 활동을 자동으로 대체하여 수동 테스팅을 제거한다.",
      "c. 모든 결함을 자동으로 발견하여 테스트 노력 추정치를 제거한다.",
      "d. 도구 사용만으로 테스트 프로세스의 성숙도를 자동으로 높인다."
    ],
    "correct_answer": "a",
    "explanation": "테스팅 도구의 주요 이점은 반복적인 작업을 자동화하고, 일관성 및 효율성을 높이는 것입니다. 도구는 테스트 활동을 '지원'할 뿐, 모든 작업을 대체하거나 모든 결함을 찾을 수는 없습니다. (FL-6.2.1 K1)"
  }
]