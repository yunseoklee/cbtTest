<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ISTQB CTFL 모의고사 CBT - Enhanced</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #5e72e4 0%, #825ee4 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2em;
            margin-bottom: 10px;
        }

        .stats-bar {
            background: rgba(255,255,255,0.1);
            padding: 10px;
            border-radius: 10px;
            margin-top: 15px;
            display: flex;
            justify-content: space-around;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 24px;
            font-weight: bold;
        }

        .stat-label {
            font-size: 12px;
            opacity: 0.9;
        }

        .tabs {
            display: flex;
            background: #f8f9fa;
            border-bottom: 2px solid #dee2e6;
            flex-wrap: wrap;
        }

        .tab {
            flex: 1;
            min-width: 100px;
            padding: 20px 15px;
            text-align: center;
            cursor: pointer;
            background: #f8f9fa;
            border: none;
            font-size: 14px;
            font-weight: 600;
            color: #495057;
            transition: all 0.3s;
            position: relative;
        }

        .tab.active {
            background: white;
            color: #5e72e4;
            border-bottom: 3px solid #5e72e4;
        }

        .tab:hover {
            background: #e9ecef;
        }

        .tab .badge {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #e74c3c;
            color: white;
            border-radius: 10px;
            padding: 2px 6px;
            font-size: 11px;
        }

        .content {
            padding: 30px;
            min-height: 500px;
        }

        .section {
            display: none;
        }

        .section.active {
            display: block;
            animation: fadeIn 0.5s;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* 용어 학습 스타일 */
        .term-card {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 20px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.08);
            position: relative;
        }

        .term-card.bookmarked {
            border: 2px solid #f39c12;
        }

        .bookmark-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #ddd;
        }

        .bookmark-btn.active {
            color: #f39c12;
        }

        .term-title {
            font-size: 24px;
            color: #2c3e50;
            margin-bottom: 15px;
            font-weight: bold;
            padding-right: 40px;
        }

        .term-definition {
            font-size: 16px;
            line-height: 1.8;
            color: #34495e;
            margin-bottom: 15px;
        }

        .term-importance {
            display: inline-block;
            padding: 5px 15px;
            background: #e74c3c;
            color: white;
            border-radius: 20px;
            font-size: 14px;
            margin-right: 10px;
        }

        .term-category {
            display: inline-block;
            padding: 5px 15px;
            background: #3498db;
            color: white;
            border-radius: 20px;
            font-size: 14px;
        }

        /* 모의고사 스타일 */
        .quiz-container {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 30px;
        }

        .question {
            font-size: 18px;
            color: #2c3e50;
            margin-bottom: 25px;
            line-height: 1.6;
        }

        .question-number {
            display: inline-block;
            background: #5e72e4;
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            margin-bottom: 15px;
            font-weight: bold;
        }

        .options {
            margin-bottom: 20px;
        }

        .option {
            background: white;
            border: 2px solid #dee2e6;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
        }

        .option:hover {
            border-color: #5e72e4;
            background: #f8f9ff;
        }

        .option.selected {
            border-color: #5e72e4;
            background: #e8ebff;
        }

        .option.correct {
            border-color: #27ae60;
            background: #d4edda;
        }

        .option.incorrect {
            border-color: #e74c3c;
            background: #f8d7da;
        }

        .option input[type="radio"] {
            margin-right: 15px;
        }

        .quiz-controls {
            display: flex;
            justify-content: space-between;
            margin-top: 30px;
        }

        .btn {
            padding: 12px 30px;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn-primary {
            background: linear-gradient(135deg, #5e72e4 0%, #825ee4 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(94, 114, 228, 0.3);
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-success {
            background: #27ae60;
            color: white;
        }

        .btn-warning {
            background: #f39c12;
            color: white;
        }

        .score-display {
            text-align: center;
            padding: 30px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 15px;
            margin-top: 20px;
        }

        .score-display h2 {
            font-size: 36px;
            margin-bottom: 10px;
        }

        /* 오답노트 스타일 */
        .review-item {
            background: #fff;
            border: 1px solid #dee2e6;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.05);
        }

        .review-item.incorrect {
            border-left: 5px solid #e74c3c;
        }

        .review-item.correct {
            border-left: 5px solid #27ae60;
        }

        .review-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .review-status {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .review-tag {
            padding: 5px 12px;
            border-radius: 15px;
            font-size: 12px;
            font-weight: 600;
        }

        .tag-incorrect {
            background: #f8d7da;
            color: #721c24;
        }

        .tag-correct {
            background: #d4edda;
            color: #155724;
        }

        .tag-category {
            background: #cce5ff;
            color: #004085;
        }

        .review-question {
            font-size: 16px;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 15px;
        }

        .review-options {
            margin-bottom: 20px;
        }

        .review-option {
            padding: 10px 15px;
            margin-bottom: 8px;
            border-radius: 8px;
            background: #f8f9fa;
            position: relative;
            padding-left: 35px;
        }

        .review-option.user-selected {
            background: #fff3cd;
            border: 1px solid #ffc107;
        }

        .review-option.correct-answer {
            background: #d4edda;
            border: 1px solid #27ae60;
        }

        .review-option::before {
            position: absolute;
            left: 10px;
            top: 50%;
            transform: translateY(-50%);
        }

        .review-option.user-selected::before {
            content: "👤";
        }

        .review-option.correct-answer::before {
            content: "✅";
        }

        .review-explanation {
            background: #e8f4fd;
            border-left: 4px solid #3498db;
            padding: 15px;
            border-radius: 5px;
            margin-top: 15px;
        }

        .review-explanation h4 {
            color: #2980b9;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .review-filters {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .filter-btn {
            padding: 8px 20px;
            border: 2px solid #dee2e6;
            background: white;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 14px;
        }

        .filter-btn.active {
            background: #5e72e4;
            color: white;
            border-color: #5e72e4;
        }

        /* 학습 진도 */
        .progress-bar {
            background: #dee2e6;
            height: 10px;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 20px;
        }

        .progress-fill {
            background: linear-gradient(90deg, #5e72e4, #825ee4);
            height: 100%;
            transition: width 0.5s;
        }

        .explanation {
            background: #e8f4fd;
            border-left: 4px solid #3498db;
            padding: 15px;
            margin-top: 15px;
            border-radius: 5px;
        }

        .explanation h4 {
            color: #2980b9;
            margin-bottom: 10px;
        }

        /* 플래시카드 스타일 개선 */
        .flashcard-container {
            perspective: 1000px;
            margin-bottom: 30px;
        }

        .flashcard {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 20px;
            padding: 40px;
            min-height: 350px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            transition: transform 0.6s;
            transform-style: preserve-3d;
            position: relative;
        }

        .flashcard:hover {
            transform: scale(1.02);
        }

        .difficulty-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 5px 15px;
            background: rgba(255,255,255,0.2);
            border-radius: 20px;
            font-size: 12px;
        }

        .study-mode-selector {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 20px;
        }

        .mode-btn {
            padding: 10px 20px;
            border: 2px solid #5e72e4;
            background: white;
            color: #5e72e4;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .mode-btn.active {
            background: #5e72e4;
            color: white;
        }

        /* 통계 대시보드 */
        .stats-dashboard {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 15px;
            text-align: center;
        }

        .stat-card h3 {
            font-size: 32px;
            margin-bottom: 5px;
        }

        .stat-card p {
            opacity: 0.9;
            font-size: 14px;
        }

        /* 반응형 디자인 */
        @media (max-width: 768px) {
            .tabs {
                overflow-x: auto;
            }
            
            .tab {
                min-width: 120px;
            }
            
            .quiz-controls {
                flex-direction: column;
                gap: 10px;
            }
            
            .btn {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🎓 ISTQB CTFL 모의고사</h1>
            <p>Certified Tester Foundation Level v4.0</p>
            <div class="stats-bar">
                <div class="stat-item">
                    <div class="stat-value" id="total-solved">0</div>
                    <div class="stat-label">총 문제</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="correct-rate">0%</div>
                    <div class="stat-label">정답률</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="study-streak">0</div>
                    <div class="stat-label">연속 학습</div>
                </div>
            </div>
        </div>

        <div class="tabs">
            <button class="tab active" onclick="showSection('terms')">📚 핵심 용어</button>
            <button class="tab" onclick="showSection('quiz')">📝 모의고사</button>
            <button class="tab" onclick="showSection('flashcard')">🔄 플래시카드</button>
            <button class="tab" onclick="showSection('review')">
                📊 오답노트
                <span class="badge" id="review-badge" style="display: none;">0</span>
            </button>
            <button class="tab" onclick="showSection('stats')">📈 학습 통계</button>
        </div>

        <div class="content">
            <!-- 핵심 용어 섹션 -->
            <div id="terms" class="section active">
                <h2 style="margin-bottom: 20px;">핵심 용어 학습</h2>
                
                <div class="filter-buttons">
                    <button class="filter-btn active" onclick="filterTerms('all')">전체</button>
                    <button class="filter-btn" onclick="filterTerms('foundation')">테스팅 기초</button>
                    <button class="filter-btn" onclick="filterTerms('lifecycle')">생명주기</button>
                    <button class="filter-btn" onclick="filterTerms('static')">정적 테스팅</button>
                    <button class="filter-btn" onclick="filterTerms('technique')">테스트 기법</button>
                    <button class="filter-btn" onclick="filterTerms('management')">테스트 관리</button>
                    <button class="filter-btn" onclick="filterTerms('bookmarked')">⭐ 북마크</button>
                </div>

                <div id="terms-container"></div>
            </div>

            <!-- 모의고사 섹션 -->
            <div id="quiz" class="section">
                <h2 style="margin-bottom: 20px;">CBT 모의고사</h2>
                
                <div class="study-mode-selector">
                    <button class="mode-btn active" onclick="setQuizMode('all')">전체</button>
                    <button class="mode-btn" onclick="setQuizMode('round_a')">1회차(A)</button>
                    <button class="mode-btn" onclick="setQuizMode('round_b')">2회차(B)</button>
                    <button class="mode-btn" onclick="setQuizMode('incorrect')">오답만</button>
                    <button class="mode-btn" onclick="setQuizMode('bookmarked')">북마크</button>
                </div>
                
                <div class="progress-bar">
                    <div class="progress-fill" id="quiz-progress" style="width: 0%;"></div>
                </div>
                <div id="quiz-container" class="quiz-container">
                    <!-- 문제가 여기에 동적으로 로드됨 -->
                </div>
            </div>

            <!-- 플래시카드 섹션 -->
            <div id="flashcard" class="section">
                <h2 style="margin-bottom: 20px;">플래시카드 학습</h2>
                
                <div class="study-mode-selector">
                    <button class="mode-btn active" onclick="setFlashcardMode('all')">전체</button>
                    <button class="mode-btn" onclick="setFlashcardMode('important')">필수암기만</button>
                    <button class="mode-btn" onclick="setFlashcardMode('bookmarked')">북마크</button>
                </div>
                
                <div id="flashcard-container" style="text-align: center;">
                    <div class="flashcard" onclick="flipCard()">
                        <div class="difficulty-indicator" id="card-importance"></div>
                        <div id="card-front">
                            <h3 id="flashcard-term" style="font-size: 32px;"></h3>
                            <p style="margin-top: 20px; opacity: 0.9;">클릭하여 정의 보기</p>
                        </div>
                        <div id="card-back" style="display: none;">
                            <p id="flashcard-definition" style="font-size: 20px; line-height: 1.8;"></p>
                        </div>
                    </div>
                    <div style="margin-top: 20px;">
                        <button class="btn btn-secondary" onclick="previousCard()">⬅ 이전</button>
                        <span style="margin: 0 20px;" id="card-counter">1 / 10</span>
                        <button class="btn btn-warning" onclick="bookmarkCard()">⭐ 북마크</button>
                        <button class="btn btn-primary" onclick="nextCard()">다음 ➡</button>
                    </div>
                </div>
            </div>

            <!-- 오답노트 섹션 -->
            <div id="review" class="section">
                <h2 style="margin-bottom: 20px;">오답노트 & 복습</h2>
                
                <div class="review-filters">
                    <button class="filter-btn active" onclick="filterReview('all')">전체</button>
                    <button class="filter-btn" onclick="filterReview('incorrect')">오답만</button>
                    <button class="filter-btn" onclick="filterReview('correct')">정답</button>
                    <button class="filter-btn" onclick="filterReview('bookmarked')">북마크</button>
                </div>
                
                <div id="review-container">
                    <!-- 오답노트 내용이 여기에 로드됨 -->
                </div>
            </div>

            <!-- 학습 통계 섹션 -->
            <div id="stats" class="section">
                <h2 style="margin-bottom: 20px;">학습 통계 대시보드</h2>
                
                <div class="stats-dashboard">
                    <div class="stat-card">
                        <h3 id="stat-total">0</h3>
                        <p>총 학습 문제</p>
                    </div>
                    <div class="stat-card">
                        <h3 id="stat-correct">0%</h3>
                        <p>전체 정답률</p>
                    </div>
                    <div class="stat-card">
                        <h3 id="stat-weak">-</h3>
                        <p>취약 영역</p>
                    </div>
                    <div class="stat-card">
                        <h3 id="stat-strong">-</h3>
                        <p>강점 영역</p>
                    </div>
                </div>
                
                <div style="margin-top: 30px;">
                    <h3>카테고리별 성과</h3>
                    <div id="category-stats" style="margin-top: 20px;">
                        <!-- 카테고리별 통계가 여기에 로드됨 -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // 오답노트 데이터 통합
        const reviewData = {
            "오답노트": [
                {"문제": "회귀 테스팅을 수행하는 가장 중요한 이유는?", "답변": "변경사항이 기존 기능에 영향을 주지 않았는지 확인", "카테고리": "테스트 레벨"},
                {"문제": "테스트 레벨의 순서로 올바른 것은?", "답변": "단위 테스팅 → 통합 테스팅 → 시스템 테스팅 → 인수 테스팅", "카테고리": "테스트 레벨"},
                {"문제": "V모델에서 단위 테스팅과 대응되는 개발 활동은?", "답변": "상세 설계", "카테고리": "테스트 레벨"},
                {"문제": "시프트 레프트(Shift-Left) 접근법의 주요 이점은?", "답변": "결함을 조기에 발견하여 수정 비용 절감", "카테고리": "테스트 원칙"},
                {"문제": "오류(Error), 결함(Defect), 장애(Failure)의 관계로 올바른 것은?", "답변": "오류가 결함을 만들고, 결함이 장애를 일으킬 수 있다", "카테고리": "테스트 기초"},
                {"문제": "동등 분할(Equivalence Partitioning) 기법의 목적은?", "답변": "입력 도메인을 동일하게 처리될 것으로 예상되는 그룹으로 나누어 대표값을 테스트", "카테고리": "테스트 기법"},
                {"문제": "경계값 분석(Boundary Value Analysis)에서 2-포인트 기법을 적용할 때 테스트하는 값은?", "답변": "유효 범위의 최솟값과 최댓값", "카테고리": "테스트 기법"},
                {"문제": "100% 구문 커버리지(Statement Coverage)를 달성했다는 의미는?", "답변": "모든 실행 가능한 코드 라인이 최소 한 번 실행되었음", "카테고리": "테스트 기법"},
                {"문제": "결정 테이블 테스팅이 가장 유용한 상황은?", "답변": "복잡한 비즈니스 규칙과 여러 조건의 조합을 테스트할 때", "카테고리": "테스트 기법"},
                {"문제": "탐색적 테스팅의 특징은?", "답변": "학습, 테스트 설계, 테스트 실행을 동시에 수행", "카테고리": "테스트 기법"},
                {"문제": "정적 테스팅과 동적 테스팅의 차이는?", "답변": "정적: 코드를 실행하지 않고 수행, 동적: 코드를 실행하며 수행", "카테고리": "정적 테스팅"},
                {"문제": "가장 공식적인 리뷰 유형은?", "답변": "인스펙션(Inspection) - 역할 정의, 체크리스트 사용, 메트릭 수집", "카테고리": "정적 테스팅"},
                {"문제": "리스크 기반 테스팅의 주요 목적은?", "답변": "제품 리스크가 높은 영역에 테스트 노력을 집중", "카테고리": "테스트 관리"},
                {"문제": "테스트 종료 조건(Exit Criteria)의 예시가 아닌 것은?", "답변": "테스트 환경 준비 완료 (이것은 진입 조건)", "카테고리": "테스트 관리"},
                {"문제": "애자일 개발에서 테스팅의 특징은?", "답변": "각 스프린트마다 지속적 테스팅과 빠른 피드백", "카테고리": "개발 방법론"},
                {"문제": "테스트 자동화가 가장 효과적인 테스트 유형은?", "답변": "회귀 테스팅 (반복 실행으로 ROI 높음)", "카테고리": "테스트 자동화"},
                {"문제": "검증(Verification)과 확인(Validation)의 차이는?", "답변": "검증: 제품을 올바르게 만드는가, 확인: 올바른 제품을 만드는가", "카테고리": "테스트 기초"},
                {"문제": "결함 우선순위와 심각도의 관계는?", "답변": "독립적으로 결정 가능 (심각도: 기술적 영향, 우선순위: 비즈니스 중요도)", "카테고리": "결함 관리"},
                {"문제": "테스트 피라미드의 구조는?", "답변": "하단에 단위 테스트(많음), 중간에 통합 테스트, 상단에 E2E 테스트(적음)", "카테고리": "테스트 전략"},
                {"문제": "테스트 오라클(Test Oracle)이란?", "답변": "테스트 실행 결과가 올바른지 판단하기 위한 정보의 소스", "카테고리": "테스트 기초"}
            ]
        };

        // 핵심 용어 데이터
        const terms = [
            {
                term: "테스팅 (Testing)",
                definition: "소프트웨어 제품과 관련 작업 산출물이 명시된 요구사항을 만족하는지 결정하고, 목적에 부합함을 입증하며, 결함을 발견하기 위한 활동",
                importance: "필수암기",
                category: "foundation",
                details: "정적/동적 활동 모두 포함, 계획/분석/설계/구현/실행/완료 활동 포함"
            },
            {
                term: "테스트 케이스 (Test Case)",
                definition: "사전조건, 입력값, 행동(해야 할 일), 기대 결과, 사후조건의 집합으로 특정 테스트 목적이나 테스트 조건을 위해 개발됨",
                importance: "필수암기",
                category: "foundation"
            },
            {
                term: "결함 (Defect/Bug/Fault)",
                definition: "작업 산출물의 불완전함이나 결점으로 인해 작업 산출물이 요구사항이나 명세를 충족시키지 못하는 것",
                importance: "필수암기",
                category: "foundation"
            },
            {
                term: "오류 (Error)",
                definition: "부정확한 결과를 만들어내는 인간의 행위",
                importance: "필수암기",
                category: "foundation"
            },
            {
                term: "장애 (Failure)",
                definition: "컴포넌트나 시스템이 요구되거나 기대된 기능을 명시된 제한 범위 내에서 수행하지 못하는 이벤트",
                importance: "필수암기",
                category: "foundation"
            },
            {
                term: "검증 (Verification)",
                definition: "작업 산출물이 해당 작업 산출물에 대한 요구사항을 제대로 반영하는지 확인 (제품을 올바르게 만들고 있는가?)",
                importance: "필수암기",
                category: "foundation"
            },
            {
                term: "확인 (Validation)",
                definition: "작업 산출물이 의도한 사용 목적을 충족하는지 확인 (올바른 제품을 만들고 있는가?)",
                importance: "필수암기",
                category: "foundation"
            },
            {
                term: "테스트 레벨 (Test Level)",
                definition: "테스트할 대상과 연관된 특정 책임을 가진 테스트 활동 그룹 (단위/통합/시스템/인수 테스팅)",
                importance: "필수암기",
                category: "lifecycle"
            },
            {
                term: "단위 테스팅 (Unit Testing)",
                definition: "개별 소프트웨어 컴포넌트를 테스트하는 테스트 레벨",
                importance: "필수암기",
                category: "lifecycle"
            },
            {
                term: "통합 테스팅 (Integration Testing)",
                definition: "통합된 컴포넌트나 시스템 간 인터페이스와 상호작용을 테스트하는 테스트 레벨",
                importance: "필수암기",
                category: "lifecycle"
            },
            {
                term: "시스템 테스팅 (System Testing)",
                definition: "완전하고 통합된 시스템이 명시된 요구사항을 만족하는지 테스트하는 레벨",
                importance: "필수암기",
                category: "lifecycle"
            },
            {
                term: "인수 테스팅 (Acceptance Testing)",
                definition: "시스템이 사용자 요구와 비즈니스 프로세스를 충족하는지 확인하는 테스트 레벨",
                importance: "필수암기",
                category: "lifecycle"
            },
            {
                term: "회귀 테스팅 (Regression Testing)",
                definition: "변경으로 인해 이전에 작동하던 소프트웨어에 결함이 생기지 않았는지 확인하는 테스팅",
                importance: "필수암기",
                category: "lifecycle"
            },
            {
                term: "정적 테스팅 (Static Testing)",
                definition: "소프트웨어를 실행하지 않고 수행하는 테스팅 (리뷰, 정적 분석)",
                importance: "필수암기",
                category: "static"
            },
            {
                term: "동적 테스팅 (Dynamic Testing)",
                definition: "소프트웨어를 실행하면서 수행하는 테스팅",
                importance: "필수암기",
                category: "static"
            },
            {
                term: "리뷰 (Review)",
                definition: "작업 산출물을 조사하여 결함을 발견하고 품질을 평가하는 정적 테스팅 활동",
                importance: "중요",
                category: "static"
            },
            {
                term: "워크스루 (Walkthrough)",
                definition: "저자가 주도하는 비공식적 리뷰 유형",
                importance: "중요",
                category: "static"
            },
            {
                term: "인스펙션 (Inspection)",
                definition: "역할이 정의되고 측정 기준을 수집하는 가장 공식적인 리뷰 유형",
                importance: "중요",
                category: "static"
            },
            {
                term: "동등 분할 (Equivalence Partitioning)",
                definition: "입력 도메인을 동일하게 처리될 것으로 예상되는 그룹으로 나누는 블랙박스 테스트 기법",
                importance: "필수암기",
                category: "technique"
            },
            {
                term: "경계값 분석 (Boundary Value Analysis)",
                definition: "분할의 경계값을 테스트 입력값으로 사용하는 블랙박스 테스트 기법",
                importance: "필수암기",
                category: "technique"
            },
            {
                term: "결정 테이블 테스팅 (Decision Table Testing)",
                definition: "조건의 조합과 그에 따른 동작을 테이블로 표현하는 블랙박스 테스트 기법",
                importance: "중요",
                category: "technique"
            },
            {
                term: "상태 전이 테스팅 (State Transition Testing)",
                definition: "시스템의 상태 변화를 테스트하는 블랙박스 테스트 기법",
                importance: "중요",
                category: "technique"
            },
            {
                term: "구문 테스팅 (Statement Testing)",
                definition: "모든 실행 가능한 구문을 테스트하는 화이트박스 테스트 기법",
                importance: "필수암기",
                category: "technique"
            },
            {
                term: "결정 테스팅 (Decision Testing)",
                definition: "모든 결정의 참/거짓 결과를 테스트하는 화이트박스 테스트 기법",
                importance: "필수암기",
                category: "technique"
            },
            {
                term: "경험 기반 테스팅 (Experience-Based Testing)",
                definition: "테스터의 지식과 경험을 활용하는 테스트 접근법 (오류 추정, 탐색적 테스팅, 체크리스트 기반)",
                importance: "중요",
                category: "technique"
            },
            {
                term: "탐색적 테스팅 (Exploratory Testing)",
                definition: "테스트 설계, 실행, 평가를 동시에 수행하는 테스팅 접근법",
                importance: "중요",
                category: "technique"
            },
            {
                term: "테스트 계획 (Test Plan)",
                definition: "테스트 목적, 범위, 접근법, 자원, 일정 등을 기술한 문서",
                importance: "필수암기",
                category: "management"
            },
            {
                term: "리스크 기반 테스팅 (Risk-Based Testing)",
                definition: "제품 리스크를 기반으로 테스트를 우선순위화하고 집중하는 접근법",
                importance: "중요",
                category: "management"
            },
            {
                term: "테스트 모니터링 (Test Monitoring)",
                definition: "테스트 진행 상황을 계획과 비교하여 추적하는 활동",
                importance: "중요",
                category: "management"
            },
            {
                term: "테스트 제어 (Test Control)",
                definition: "테스트 목적 달성을 위해 필요한 시정 조치를 취하는 활동",
                importance: "중요",
                category: "management"
            },
            {
                term: "진입 조건 (Entry Criteria)",
                definition: "테스트 활동을 시작하기 위한 전제 조건",
                importance: "중요",
                category: "management"
            },
            {
                term: "종료 조건 (Exit Criteria)",
                definition: "테스트 활동을 완료하기 위한 조건",
                importance: "중요",
                category: "management"
            },
            {
                term: "테스트 추정 (Test Estimation)",
                definition: "테스트에 필요한 자원과 시간을 예측하는 활동",
                importance: "중요",
                category: "management"
            },
            {
                term: "결함 관리 (Defect Management)",
                definition: "결함을 인지, 기록, 분류, 조사, 해결, 처리하는 프로세스",
                importance: "필수암기",
                category: "management"
            },
            {
                term: "테스트 커버리지 (Test Coverage)",
                definition: "테스트가 특정 커버리지 항목을 실행한 정도 (백분율로 표현)",
                importance: "필수암기",
                category: "technique"
            },
            {
                term: "테스트 오라클 (Test Oracle)",
                definition: "테스트 실행 결과를 판단하기 위한 기준이나 소스",
                importance: "중요",
                category: "foundation"
            },
            {
                term: "시프트 레프트 (Shift Left)",
                definition: "소프트웨어 개발 생명주기의 초기 단계에서 테스팅을 수행하는 접근법",
                importance: "중요",
                category: "lifecycle"
            },
            {
                term: "테스트 피라미드 (Test Pyramid)",
                definition: "단위 테스트를 기반으로 하고 상위 레벨로 갈수록 테스트 수가 줄어드는 구조",
                importance: "중요",
                category: "management"
            }
        ];

        // 모의고사 문제 데이터 (오답노트 내용 반영하여 확장)
        const quizQuestions = [
{
                id: "A4",
                original_id: "A4",
                question: "다음 중 테스트 설계 활동은?",
                options: ["a. 테스트 노력을 추정한다", "b. 테스트 케이스를 설계한다", "c. 커버리지 아이템을 도출한다", "d. 결함을 보고한다"],
                correct: 2,
                explanation: "테스트 설계 활동은 테스트 컨디션(테스트 대상)을 커버하는 테스트 케이스를 설계하고, 이 테스트 케이스가 커버할 항목(커버리지 아이템)을 도출하는 활동을 포함합니다. 테스트 노력을 추정하는 것은 테스트 계획, 결함 보고는 테스트 실행 중의 활동입니다. (FL-1.4.1 K2)",
                chapter: "1.4.1",
                k_level: "K2",
                category: "istqb"
            },{
                id: "A5",
                original_id: "A5",
                question: "다음 중 테스트 실행 활동에 포함되지 않는 것은?",
                options: ["a. 테스트 스위트를 빌드한다", "b. 테스트 로그를 생성한다", "c. 결함 보고서를 기록한다", "d. 기대 결과를 결정한다"],
                correct: 3,
                explanation: "테스트 실행 활동은 테스트 로그 생성, 결과 비교, 결함 보고서 기록을 포함합니다. **기대 결과(Expected Result)를 결정**하는 것은 **테스트 설계** 활동의 일부입니다. (FL-1.4.3 K2)",
                chapter: "1.4.3",
                k_level: "K2",
                category: "istqb"
            },{
                id: "A6",
                original_id: "A6",
                question: "개발자와 테스터 간의 효과적인 협업을 위해 필요한 테스터의 소프트 스킬은? i. 비즈니스 언어 이해 ii. 제품 비전 수립 능력 iii. 공감 능력 iv. 좋은 팀 구성원 되기",
                options: ["a. i, ii, iii", "b. i, iii, iv", "c. ii, iii, iv", "d. i, ii, iv"],
                correct: 1,
                explanation: "테스터는 효과적인 협업을 위해 공감, 비즈니스 언어 이해, 그리고 좋은 팀 구성원으로서의 역량(i, iii, iv)을 갖추어야 합니다. **제품 비전 수립** 능력(ii)은 주로 제품 소유자나 비즈니스 분석가의 역할입니다. (FL-1.5.1 K2)",
                chapter: "1.5.1",
                k_level: "K2",
                category: "istqb"
            },{
                id: "A10",
                original_id: "A10",
                question: "다음 중 테스트 주도 개발(TDD)을 가장 잘 설명한 것은?",
                options: ["a. 인수 조건을 given/when/then 형식으로 작성한다", "b. 인수 조건을 기반으로 테스트를 작성한다", "c. 코드를 작성하기 전에 테스트를 작성한다", "d. 개발과 테스팅을 분리한다"],
                correct: 2,
                explanation: "테스트 주도 개발(TDD)은 실제 코드를 구현하기 **전에** 실패하는(Red) 테스트를 먼저 작성하고, 그 테스트를 통과시키는 코드(Green)를 작성한 후, 코드를 리팩토링(Refactor)하는 프로세스입니다. (FL-2.1.3 K2)",
                chapter: "2.1.3",
                k_level: "K2",
                category: "istqb"
            },{
                id: "A12",
                original_id: "A12",
                question: "다음 중 컴포넌트 테스팅의 테스트 베이시스는?",
                options: ["a. 사용자 스토리", "b. 시스템 요구사항 명세서", "c. 상세 설계 명세서", "d. 운영 설명서"],
                correct: 2,
                explanation: "컴포넌트 테스팅(단위 테스팅)은 가장 낮은 레벨의 테스팅으로, 테스트 베이시스로는 주로 **상세 설계 명세서**나 컴포넌트 사양, 또는 코드 자체가 사용됩니다. 사용자 스토리나 시스템 요구사항은 시스템/인수 테스팅의 베이시스입니다. (FL-2.2.1 K2)",
                chapter: "2.2.1",
                k_level: "K2",
                category: "istqb"
            },{
                id: "A14",
                original_id: "A14",
                question: "다음 중 인수 테스팅의 일반적인 목표는?",
                options: ["a. 시스템이 비즈니스 요구사항을 충족한다는 신뢰를 구축한다", "b. 시스템의 구조적 무결성을 평가한다", "c. 시스템의 통합 문제를 발견한다", "d. 시스템의 성능을 최적화한다"],
                correct: 0,
                explanation: "인수 테스팅(Acceptance Testing)은 시스템이 사용자나 **비즈니스 요구사항**을 충족하는지 최종적으로 확인하고 신뢰를 구축하는 데 중점을 둡니다. (FL-2.2.4 K2)",
                chapter: "2.2.4",
                k_level: "K2",
                category: "istqb"
            },{
                id: "A15",
                original_id: "A15",
                question: "다음 중 기능 테스팅의 예시가 아닌 것은?",
                options: ["a. 사용자 스토리 테스팅", "b. 비즈니스 시나리오 테스팅", "c. 보안 테스팅", "d. 상호 운용성 테스팅"],
                correct: 3,
                explanation: "기능 테스팅은 시스템이 무엇을 '하는지'를 테스트합니다. 사용자 스토리(a)와 비즈니스 시나리오(b)는 기능 테스팅입니다. 보안 테스팅(c)과 **상호 운용성 테스팅(d)**은 시스템이 어떻게 작동하는지와 관련된 **비기능 테스팅**입니다. (FL-2.3.1 K2)",
                chapter: "2.3.1",
                k_level: "K2",
                category: "istqb"
            },{
                id: "A16",
                original_id: "A16",
                question: "다음 중 확인 테스팅(Confirmation Testing)의 목적은?",
                options: ["a. 변경으로 인해 의도하지 않은 결함이 발생하지 않았는지 확인한다", "b. 수정된 결함이 원래의 결함을 성공적으로 제거했는지 확인한다", "c. 새로운 기능이 올바르게 구현되었는지 확인한다", "d. 고위험 영역에 집중하여 테스트 노력을 최소화한다"],
                correct: 1,
                explanation: "확인 테스팅은 **수정된 결함이 원래의 결함을 성공적으로 제거했는지** 확인하는 활동입니다. 변경으로 인한 부작용 확인(a)은 리그레션 테스팅의 목적입니다. (FL-2.4.1 K2)",
                chapter: "2.4.1",
                k_level: "K2",
                category: "istqb"
            },{
                id: "A17",
                original_id: "A17",
                question: "정적 테스팅의 이점으로 가장 적절하지 않은 것은?",
                options: ["a. 결함을 조기에 발견한다", "b. 테스트 환경이 준비되지 않아도 수행할 수 있다", "c. 코드 실행 없이 테스트 베이시스 결함을 식별한다", "d. 런타임 오류의 성능 영향을 정확하게 평가한다"],
                correct: 3,
                explanation: "정적 테스팅은 **코드 실행 없이** 문서나 코드를 검토하는 활동이므로, 런타임 오류나 성능 영향과 같은 **동적** 품질 특성을 평가할 수는 없습니다. (FL-3.1.2 K2)",
                chapter: "3.1.2",
                k_level: "K2",
                category: "istqb"
            },{
                id: "A18",
                original_id: "A18",
                question: "리뷰의 네 가지 주요 활동의 올바른 순서는? i. 개별 준비 ii. 시작 iii. 수정 및 보고 iv. 커뮤니케이션 및 분석",
                options: ["a. ii → i → iv → iii", "b. i → ii → iv → iii", "c. i → iv → ii → iii", "d. ii → iv → i → iii"],
                correct: 0,
                explanation: "리뷰 프로세스의 네 가지 주요 활동은 **시작(ii)** → **개별 준비(i)** → **커뮤니케이션 및 분석(iv)** → **수정 및 보고(iii)** 순서로 진행됩니다. (FL-3.2.1 K1)",
                chapter: "3.2.1",
                k_level: "K1",
                category: "istqb"
            },{
                id: "A20",
                original_id: "A20",
                question: "1에서 10까지의 점수를 입력해야 하는 명세에 대해 **동등 분할**을 적용했을 때, 최소한의 테스트 케이스 입력값은?",
                options: ["a. 3개", "b. 4개", "c. 5개", "d. 6개"],
                correct: 0,
                explanation: "유효 범위는 [1, 10]입니다. 동등 분할은 다음 세 가지 동등 클래스를 식별합니다: 1. **유효** 동등 클래스: [1, 10] (예: 5) 2. **비유효** 동등 클래스: <1 (예: 0) 3. **비유효** 동등 클래스: >10 (예: 11). 각 클래스에서 최소 1개의 입력값이 필요하므로 총 **3개**의 테스트 케이스가 필요합니다. (FL-4.2.1 K3)",
                chapter: "4.2.1",
                k_level: "K3",
                category: "istqb"
            },{
                id: "A21",
                original_id: "A21",
                question: "주어진 코드: `if (점수 >= 50) { if (점수 <= 100) { 결과 = '합격'; } }` 경계값 분석을 적용하여 테스트 케이스를 설계할 때, 테스트해야 할 **유효한** 경계값은?",
                options: ["a. 49, 101", "b. 50, 100", "c. 50, 51, 99, 100", "d. 49, 50, 100, 101"],
                correct: 1,
                explanation: "유효 범위는 50과 100 사이([50, 100])입니다. **유효한** 경계값은 범위에 포함되는 경계 자체의 값입니다. 따라서 **50과 100**이 유효 경계값입니다. (FL-4.2.2 K3)",
                chapter: "4.2.2",
                k_level: "K3",
                category: "istqb"
            },{
                id: "A22",
                original_id: "A22",
                question: "명세: (C1) '고객은 이메일을 입력한다' AND (C2) '이메일이 유효하다' 일 때, (A1) '성공 메시지를 표시한다'. 그 외 모든 경우 (A2) '오류 메시지를 표시한다'. 결정 테이블 기법을 적용했을 때, 최소한으로 필요한 테스트 케이스의 수는?",
                options: ["a. 2개", "b. 3개", "c. 4개", "d. 5개"],
                correct: 2,
                explanation: "조건이 C1과 C2, 총 2개이므로, 가능한 모든 조건의 조합은 $2^2=4$ 개입니다 (T/T, T/F, F/T, F/F). 결정 테이블은 이 4가지 규칙을 모두 포함해야 하므로 최소 **4개**의 테스트 케이스가 필요합니다. (FL-4.2.3 K3)",
                chapter: "4.2.3",
                k_level: "K3",
                category: "istqb"
            },{
                id: "A24",
                original_id: "A24",
                question: "다음 코드에 대해 **분기 커버리지** 100%를 달성하기 위한 최소한의 테스트 케이스 입력(x, y)은? `if (x > 0) { if (y > 0) { print('A'); } else { print('B'); } } else { print('C'); }`",
                options: ["a. 1개", "b. 2개", "c. 3개", "d. 4개"],
                correct: 2,
                explanation: "분기 커버리지 100%는 모든 분기(조건)의 참/거짓 결과가 최소 한 번씩 실행되어야 합니다. 최소 **3개**의 독립적인 테스트 케이스 (x>0 & y>0, x>0 & y≤0, x≤0)가 필요합니다. (FL-4.3.1 K3)",
                chapter: "4.3.1",
                k_level: "K3",
                category: "istqb"
            },{
                id: "A25",
                original_id: "A25",
                question: "탐색적 테스팅에 대한 설명으로 가장 적절한 것은?",
                options: ["a. 문서화된 절차를 기반으로 한다", "b. 테스트 케이스를 미리 설계한다", "c. 테스터의 경험을 기반으로 테스트를 설계하고 실행한다", "d. 주로 자동화된 테스트에 사용된다"],
                correct: 2,
                explanation: "탐색적 테스팅(Exploratory Testing)은 테스터의 **경험**과 **학습**을 기반으로 테스트 케이스 설계와 실행을 동시에 진행하는 비공식적이고 경험 기반의 테스팅 기법입니다. (FL-4.4.1 K2)",
                chapter: "4.4.1",
                k_level: "K2",
                category: "istqb"
            },{
                id: "A27",
                original_id: "A27",
                question: "테스트 계획의 주요 목적은?",
                options: ["a. 테스트 환경 설정", "b. 테스트 팀 구성", "c. 결함 재현", "d. 테스트 활동의 범위, 목표, 접근 방식을 정의"],
                correct: 3,
                explanation: "테스트 계획은 테스트 활동의 **범위, 목표, 접근 방식**을 정의하여 테스트 노력을 안내하고, 이해관계자가 테스트 프로세스를 이해하도록 지원하는 데 중점을 둡니다. (FL-5.1.2 K2)",
                chapter: "5.1.2",
                k_level: "K2",
                category: "istqb"
            },{
                id: "A28",
                original_id: "A28",
                question: "테스트 계획에 영향을 미치는 요인 두 가지는? i. 테스트 정책 ii. 테스트 추정 iii. 테스트 팀의 기술 iv. 시스템의 복잡도",
                options: ["a. i, iv", "b. ii, iii", "c. i, iii", "d. ii, iv"],
                correct: 0,
                explanation: "테스트 정책(조직의 테스팅 지침)과 시스템의 복잡도(테스트 대상의 특성)는 테스트 활동의 **접근 방식과 노력**에 큰 영향을 미치므로 테스트 계획에 중대한 영향을 미치는 요인입니다. (FL-5.1.3 K2)",
                chapter: "5.1.3",
                k_level: "K2",
                category: "istqb"
            },{
                id: "A29",
                original_id: "A29",
                question: "테스트 추정 기법 중 **플래닝 포커(Planning Poker)**에 대한 설명으로 가장 적절한 것은?",
                options: ["a. 전문가의 경험을 기반으로 한다", "b. 테스트 노력을 계산하는 공식을 사용한다", "c. 팀원들의 합의를 도출하는 구조화된 방식이다", "d. 이전 프로젝트의 데이터를 기반으로 한다"],
                correct: 2,
                explanation: "플래닝 포커는 와이드밴드 델파이 기법의 변형으로, 팀원들의 **합의**를 통해 추정치를 도출하는 **구조화된** 접근 방식입니다. (FL-5.1.4 K3)",
                chapter: "5.1.4",
                k_level: "K3",
                category: "istqb"
            },{
                id: "A30",
                original_id: "A30",
                question: "다음 중 **제품 리스크**의 예시는?",
                options: ["a. 테스트 환경 준비 지연", "b. 시스템이 요구사항을 충족하지 못할 가능성", "c. 인력 부족", "d. 예산 초과"],
                correct: 1,
                explanation: "**제품 리스크**는 소프트웨어의 **품질**이나 기능이 요구사항을 충족하지 못할 가능성과 관련됩니다. 테스트 환경 지연, 인력 부족, 예산 초과는 **프로젝트 리스크**에 해당합니다. (FL-5.2.2 K2)",
                chapter: "5.2.2",
                k_level: "K2",
                category: "istqb"
            },{
                id: "A31",
                original_id: "A31",
                question: "테스트 모니터링 활동의 주요 목적은?",
                options: ["a. 이해관계자에게 테스트 활동에 대한 가시성을 제공한다", "b. 테스트 케이스를 설계하고 구현한다", "c. 테스트 리포트를 작성한다", "d. 결함을 수정한다"],
                correct: 0,
                explanation: "테스트 모니터링은 테스트 활동의 진행 상황과 상태를 추적하고, 이해관계자에게 **가시성을 제공**하여 올바른 의사결정을 지원하는 데 중점을 둡니다. (FL-5.3.1 K2)",
                chapter: "5.3.1",
                k_level: "K2",
                category: "istqb"
            },{
                id: "B1",
                original_id: "B1",
                question: "테스팅의 주요 목표가 아닌 것은?",
                options: ["a. 결함을 발견하고 잠재적인 장애 위험을 줄이는 것", "b. 소프트웨어 시스템의 품질 수준을 낮추는 것", "c. 시스템이 요구사항을 충족한다는 신뢰를 구축하는 것", "d. 프로젝트 이해관계자에게 적절한 정보를 제공하여 의사 결정을 지원하는 것"],
                correct: 1,
                explanation: "테스팅의 주요 목표는 소프트웨어의 품질 수준을 **높이는 것**입니다. 결함을 발견하고 신뢰를 구축하며, 정보 제공을 통해 의사 결정을 돕는 것이 테스팅의 핵심 목표입니다. (FL-1.1.2 K2)",
                chapter: "1.1.2",
                k_level: "K2",
                category: "istqb"
            },{
                id: "B2",
                original_id: "B2",
                question: "테스팅이 프로젝트의 성공에 기여하는 방법은?",
                options: ["a. 시스템에서 결함이 전혀 발견되지 않음을 보증한다", "b. 프로젝트 이해관계자에게 적절한 **정보**를 제공하여 **의사 결정**을 지원한다", "c. 소프트웨어 개발팀의 생산성을 측정한다", "d. 사용자에게 시스템이 항상 기대하는 대로 작동할 것임을 보증한다"],
                correct: 1,
                explanation: "테스팅은 프로젝트 상태와 품질에 대한 객관적인 정보를 이해관계자에게 제공하여, 프로젝트의 목표 및 일정에 대한 **정보에 기반한 의사 결정**을 지원함으로써 성공에 기여합니다. 테스팅은 결함이 없음을 '보증'할 수 없습니다. (FL-1.1.2 K2)",
                chapter: "1.1.2",
                k_level: "K2",
                category: "istqb"
            },{
                id: "B3",
                original_id: "B3",
                question: "테스트 원칙 '결함 집중(Defect Clustering)'에 대한 설명은?",
                options: ["a. 테스팅의 긍정적인 측면은 결함이 없음을 보여주는 것이다", "b. 결함은 항상 시스템 전체에 균등하게 분포되어 있다", "c. 대부분의 결함은 소수의 모듈에 집중되어 존재한다", "d. 오류를 제거할수록 더 적은 결함이 발견될 가능성이 낮아진다"],
                correct: 2,
                explanation: "결함 집중 원칙은 시스템의 모든 부분이 동일한 확률로 실패하지 않으며, 대부분의 결함과 관련된 운영상의 실패가 **소수의 모듈에 집중**되어 있음을 나타냅니다. (FL-1.2.2 K2)",
                chapter: "1.2.2",
                k_level: "K2",
                category: "istqb"
            },{
                id: "B16",
                original_id: "B16",
                question: "테스트 레벨 간의 주요 차이점은 무엇인가?",
                options: ["a. 소프트웨어 테스트 단계 및 개발 모델", "b. 테스트 베이시스, 테스트 목표, 테스팅 대상", "c. 테스팅 유형 및 테스팅의 비기능적 목표", "d. 테스터의 기술적 역량 및 테스트 환경 구성"],
                correct: 1,
                explanation: "테스트 레벨(예: 컴포넌트, 통합, 시스템, 인수 테스팅)은 각각 **테스트 베이시스** (무엇을 기반으로 테스트하는가), **테스트 목표** (무엇을 검증하려고 하는가), 그리고 **테스팅 대상** (무엇을 테스트하는가)이 다릅니다. (FL-2.2.1 K2)",
                chapter: "2.2.1",
                k_level: "K2",
                category: "istqb"
            },{
                id: "B17",
                original_id: "B17",
                question: "다음 중 컴포넌트 테스팅의 특징이 아닌 것은?",
                options: ["a. 테스트 베이시스로 상세 설계 명세서가 사용될 수 있다", "b. 일반적으로 개발 환경에서 수행된다", "c. 테스터는 일반적으로 **요구사항 명세서**를 테스트 베이시스로 사용한다", "d. 스텁과 드라이버를 사용하여 수행될 수 있다"],
                correct: 2,
                explanation: "**컴포넌트 테스팅(단위 테스팅)**은 가장 낮은 레벨의 테스팅으로, 주로 **상세 설계 명세서**나 **컴포넌트 사양**, 또는 **코드**를 테스트 베이시스로 사용합니다. 요구사항 명세서는 주로 시스템 및 인수 테스팅의 베이시스입니다. (FL-2.2.1 K2)",
                chapter: "2.2.1",
                k_level: "K2",
                category: "istqb"
            },{
                id: "B19",
                original_id: "B19",
                question: "성능 테스팅의 주요 목적은?",
                options: ["a. 시스템의 응답 시간 및 처리량과 같은 비기능적 품질 특성을 평가한다", "b. 시스템이 올바른 기능을 수행하는지 확인한다", "c. 사용자 입력 유효성 검사가 올바르게 작동하는지 확인한다", "d. 시스템의 구조적 무결성을 평가한다"],
                correct: 0,
                explanation: "성능 테스팅은 비기능 테스팅의 한 유형으로, 시스템이 **특정 응답 시간이나 처리량**과 같은 성능 요구사항을 충족하는지 평가하는 데 중점을 둡니다. (FL-2.3.2 K2)",
                chapter: "2.3.2",
                k_level: "K2",
                category: "istqb"
            },{
                id: "B20",
                original_id: "B20",
                question: "리그레션 테스팅(Regression Testing)에 대한 가장 적절한 설명은?",
                options: ["a. 결함이 수정되었음을 확인하는 테스트", "b. 시스템이 사용자 요구사항을 충족하는지 확인하는 테스트", "c. 변경으로 인해 의도하지 않은 영향이나 결함이 발생하지 않았는지 확인하는 테스트", "d. 새로운 기능이 올바르게 작동하는지 확인하는 테스트"],
                correct: 2,
                explanation: "리그레션 테스팅(회귀 테스팅)은 **변경** (결함 수정, 환경 변경, 기능 추가 등)이 시스템의 **기존에 잘 작동하던 부분**에 의도하지 않은 부작용(결함)을 초래하지 않았는지 확인하는 활동입니다. (FL-2.4.1 K2)",
                chapter: "2.4.1",
                k_level: "K2",
                category: "istqb"
            },{
                id: "B21",
                original_id: "B21",
                question: "동등 분할(Equivalence Partitioning)과 경계값 분석(Boundary Value Analysis) 기법을 사용하는 단계는?",
                options: ["a. 테스트 구현", "b. 테스트 종료", "c. 테스트 설계", "d. 테스트 모니터링"],
                correct: 2,
                explanation: "동등 분할과 경계값 분석은 **블랙박스 테스트 기법**으로, 테스트 조건을 커버하는 **테스트 케이스를 식별하고 설계**하는 활동(테스트 설계)에서 사용됩니다. (FL-4.2.1 K2)",
                chapter: "4.2.1",
                k_level: "K2",
                category: "istqb"
            },{
                id: "B22",
                original_id: "B22",
                question: "상태 전이 테스팅(State Transition Testing)이 가장 적합한 경우는?",
                options: ["a. 입력의 유효성과 무효성을 테스트할 때", "b. 코드 라인이 실행되었는지 확인할 때", "c. 시스템의 **상태**와 **상태 간의 전이**가 명확하게 정의된 경우", "d. 입력 조건의 조합을 테스트할 때"],
                correct: 2,
                explanation: "**상태 전이 테스팅**은 시스템이 **상태(State)**와 그 상태 간의 **전이(Transition)**를 기반으로 동작할 때 (예: 워크플로우, 메뉴 기반 시스템) 가장 적합한 블랙박스 기법입니다. (FL-4.2.4 K2)",
                chapter: "4.2.4",
                k_level: "K2",
                category: "istqb"
            },{
                id: "B30",
                original_id: "B30",
                question: "다음 중 테스트 케이스를 설계하는 화이트박스 기법은?",
                options: ["a. 동등 분할", "b. 유스 케이스 테스팅", "c. **구문 테스팅**", "d. 상태 전이 테스팅"],
                correct: 2,
                explanation: "화이트박스(구조 기반) 테스팅 기법은 소프트웨어의 내부 구조를 기반으로 합니다. **구문 테스팅(Statement Testing)**과 **결정 테스팅(Decision Testing)**이 대표적입니다. 나머지 옵션은 모두 블랙박스 기법입니다. (FL-4.3.1 K2)",
                chapter: "4.3.1",
                k_level: "K2",
                category: "istqb"
            },{
                id: "B31",
                original_id: "B31",
                question: "테스트 계획서에 포함되는 내용으로 가장 적절한 것은?",
                options: ["a. 테스트 데이터 생성 도구의 이름", "b. 테스트 활동의 범위, 목표, **접근 방식(Approach)**", "c. 각 테스트 케이스의 상세한 실행 단계", "d. 모든 잠재적 프로젝트 리스크의 우선순위"],
                correct: 1,
                explanation: "테스트 계획서의 핵심은 **테스트 활동의 범위(Scope), 목표(Objectives), 접근 방식(Approach)**을 문서화하는 것입니다. (FL-5.1.2 K2)",
                chapter: "5.1.2",
                k_level: "K2",
                category: "istqb"
            },{
                id: "B32",
                original_id: "B32",
                question: "테스트 추정 기법 중 **전문가 기반 기법**의 예시는?",
                options: ["a. 테스트 베이시스의 크기 계산", "b. **델파이 기법 (Delphi Technique)**", "c. 회귀 분석", "d. 메트릭 기반 추정"],
                correct: 1,
                explanation: "**델파이 기법(Delphi Technique)**과 **플래닝 포커(Planning Poker)**는 전문가의 경험과 지식을 활용하여 추정치를 도출하는 대표적인 전문가 기반 기법입니다. (FL-5.1.4 K2)",
                chapter: "5.1.4",
                k_level: "K2",
                category: "istqb"
            },{
                id: "B34",
                original_id: "B34",
                question: "테스트 모니터링 및 제어 활동에 대해 잘못 설명한 것은?",
                options: ["a. 테스트 제어는 계획과 실제 간의 편차를 줄이기 위한 조치를 취한다", "b. 테스트 제어는 모니터링 결과와 **독립적으로** 수행된다", "c. 테스트 모니터링은 진행 상황을 측정하고 추적한다", "d. 모니터링 결과는 테스트 활동에 대한 의사 결정을 내리는 데 사용된다"],
                correct: 1,
                explanation: "**테스트 제어**는 **테스트 모니터링**을 통해 파악된 진행 상황 및 편차 정보를 기반으로 수행됩니다. 따라서 독립적으로 수행된다는 설명은 잘못되었습니다. (FL-5.3.3 K2)",
                chapter: "5.3.3",
                k_level: "K2",
                category: "istqb"
            },{
                id: "B35",
                original_id: "B35",
                question: "결함 보고서의 주요 목적은?",
                options: ["a. 테스트 팀의 성과를 측정한다", "b. 결함의 근본 원인을 분석한다", "c. 개발자가 결함을 **재현**하고 **수정**할 수 있도록 정보를 제공한다", "d. 결함 보고서의 심각도를 변경한다"],
                correct: 2,
                explanation: "결함 보고서의 가장 주된 목적은 개발자가 결함을 **재현, 이해, 수정**하는 데 필요한 충분한 정보를 제공하는 것입니다. (FL-5.4.1 K2)",
                chapter: "5.4.1",
                k_level: "K2",
                category: "istqb"
            },{
                id: "B37",
                original_id: "B37",
                question: "다음 중 테스트 완료 활동의 목적은?",
                options: ["a. 다음 테스트 레벨의 테스트 환경을 구축한다", "b. 테스트 종료 보고서를 작성하고 테스트 자산을 보관한다", "c. 모든 결함이 수정되고 닫혔는지 확인한다", "d. 테스트 실행에 필요한 모든 승인을 얻는다"],
                correct: 1,
                explanation: "테스트 완료 활동은 보고서 작성, 테스트웨어 보관, 교훈(Lessons Learned) 수집 및 테스트 활동 종료를 위한 기타 클로징 작업을 포함합니다. (FL-5.5.1 K2)",
                chapter: "5.5.1",
                k_level: "K2",
                category: "istqb"
            }
        ];

        // 전역 변수
        let currentQuestionIndex = 0;
        let currentCardIndex = 0;
        let score = 0;
        let answeredQuestions = [];
        let currentFilter = 'all';
        let quizMode = 'all';
        let flashcardMode = 'all';
        let bookmarkedTerms = new Set();
        let bookmarkedQuestions = new Set();
        let incorrectQuestions = new Set();

        // LocalStorage 키
        const STORAGE_KEYS = {
            BOOKMARKED_TERMS: 'istqb_bookmarked_terms',
            BOOKMARKED_QUESTIONS: 'istqb_bookmarked_questions',
            INCORRECT_QUESTIONS: 'istqb_incorrect_questions',
            ANSWERED_HISTORY: 'istqb_answered_history',
            STATS: 'istqb_stats'
        };

        // 초기화
        document.addEventListener('DOMContentLoaded', function() {
            loadFromStorage();
            displayTerms('all');
            loadFlashcard();
            updateStats();
            updateReviewBadge();
        });

        // LocalStorage에서 데이터 로드
        function loadFromStorage() {
            try {
                const savedBookmarkedTerms = localStorage.getItem(STORAGE_KEYS.BOOKMARKED_TERMS);
                const savedBookmarkedQuestions = localStorage.getItem(STORAGE_KEYS.BOOKMARKED_QUESTIONS);
                const savedIncorrectQuestions = localStorage.getItem(STORAGE_KEYS.INCORRECT_QUESTIONS);
                const savedAnsweredHistory = localStorage.getItem(STORAGE_KEYS.ANSWERED_HISTORY);
                
                if (savedBookmarkedTerms) bookmarkedTerms = new Set(JSON.parse(savedBookmarkedTerms));
                if (savedBookmarkedQuestions) bookmarkedQuestions = new Set(JSON.parse(savedBookmarkedQuestions));
                if (savedIncorrectQuestions) incorrectQuestions = new Set(JSON.parse(savedIncorrectQuestions));
                if (savedAnsweredHistory) answeredQuestions = JSON.parse(savedAnsweredHistory);
            } catch (e) {
                console.error('Failed to load from storage:', e);
            }
        }

        // LocalStorage에 데이터 저장
        function saveToStorage() {
            try {
                localStorage.setItem(STORAGE_KEYS.BOOKMARKED_TERMS, JSON.stringify(Array.from(bookmarkedTerms)));
                localStorage.setItem(STORAGE_KEYS.BOOKMARKED_QUESTIONS, JSON.stringify(Array.from(bookmarkedQuestions)));
                localStorage.setItem(STORAGE_KEYS.INCORRECT_QUESTIONS, JSON.stringify(Array.from(incorrectQuestions)));
                localStorage.setItem(STORAGE_KEYS.ANSWERED_HISTORY, JSON.stringify(answeredQuestions));
            } catch (e) {
                console.error('Failed to save to storage:', e);
            }
        }

        // 섹션 전환
        function showSection(sectionName) {
            // 모든 탭과 섹션 비활성화
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.section').forEach(section => section.classList.remove('active'));
            
            // 선택된 탭과 섹션 활성화
            event.target.classList.add('active');
            document.getElementById(sectionName).classList.add('active');
            
            // 각 섹션별 초기화
            if (sectionName === 'quiz') {
                startQuiz();
            } else if (sectionName === 'review') {
                displayReviewItems();
            } else if (sectionName === 'stats') {
                displayStats();
            }
        }

        // 용어 필터링
        function filterTerms(category) {
            currentFilter = category;
            document.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            displayTerms(category);
        }

        // 용어 표시
        function displayTerms(category) {
            const container = document.getElementById('terms-container');
            container.innerHTML = '';
            
            let filteredTerms = terms;
            
            if (category === 'bookmarked') {
                filteredTerms = terms.filter((t, index) => bookmarkedTerms.has(index));
            } else if (category !== 'all') {
                filteredTerms = terms.filter(t => t.category === category);
            }
            
            filteredTerms.forEach((term, originalIndex) => {
                const actualIndex = terms.indexOf(term);
                const termCard = document.createElement('div');
                termCard.className = 'term-card';
                if (bookmarkedTerms.has(actualIndex)) {
                    termCard.classList.add('bookmarked');
                }
                
                termCard.innerHTML = `
                    <button class="bookmark-btn ${bookmarkedTerms.has(actualIndex) ? 'active' : ''}" 
                            onclick="toggleTermBookmark(${actualIndex})">
                        ${bookmarkedTerms.has(actualIndex) ? '⭐' : '☆'}
                    </button>
                    <div class="term-title">${term.term}</div>
                    <div class="term-definition">${term.definition}</div>
                    ${term.details ? `<div class="term-definition" style="font-size: 14px; color: #7f8c8d; margin-top: 10px;">💡 ${term.details}</div>` : ''}
                    <div>
                        <span class="term-importance">${term.importance}</span>
                        <span class="term-category">${getCategoryName(term.category)}</span>
                    </div>
                `;
                container.appendChild(termCard);
            });
        }

        // 용어 북마크 토글
        function toggleTermBookmark(index) {
            if (bookmarkedTerms.has(index)) {
                bookmarkedTerms.delete(index);
            } else {
                bookmarkedTerms.add(index);
            }
            saveToStorage();
            displayTerms(currentFilter);
        }

        // 카테고리 이름 변환
        function getCategoryName(category) {
            const names = {
                'foundation': '테스팅 기초',
                'lifecycle': '생명주기',
                'static': '정적 테스팅',
                'technique': '테스트 기법',
                'management': '테스트 관리'
            };
            return names[category] || category;
        }

        // 모의고사 모드 설정
        function setQuizMode(mode) {
            quizMode = mode;
            document.querySelectorAll('.study-mode-selector .mode-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            startQuiz();
        }

        // 모의고사 시작
        function startQuiz() {
            currentQuestionIndex = 0;
            score = 0;
            
            // 모드에 따라 문제 필터링
            let filteredQuestions = [...quizQuestions];
            
            if (quizMode === 'round_a') {
                // A로 시작하는 ID 필터
                filteredQuestions = quizQuestions.filter(q => {
                    return q.original_id && q.original_id.toString().startsWith('A');
                });
                if (filteredQuestions.length === 0) {
                    document.getElementById('quiz-container').innerHTML = `
                        <div style="text-align: center; padding: 50px;">
                            <h3>1회차(A) 문제가 없습니다!</h3>
                            <button class="btn btn-primary" onclick="setQuizMode('all')">전체 문제 풀기</button>
                        </div>
                    `;
                    return;
                }
            } else if (quizMode === 'round_b') {
                // B로 시작하는 ID 필터
                filteredQuestions = quizQuestions.filter(q => {
                    return q.original_id && q.original_id.toString().startsWith('B');
                });
                if (filteredQuestions.length === 0) {
                    document.getElementById('quiz-container').innerHTML = `
                        <div style="text-align: center; padding: 50px;">
                            <h3>2회차(B) 문제가 없습니다!</h3>
                            <button class="btn btn-primary" onclick="setQuizMode('all')">전체 문제 풀기</button>
                        </div>
                    `;
                    return;
                }
            } else if (quizMode === 'incorrect') {
                filteredQuestions = quizQuestions.filter(q => incorrectQuestions.has(q.id));
                if (filteredQuestions.length === 0) {
                    document.getElementById('quiz-container').innerHTML = `
                        <div style="text-align: center; padding: 50px;">
                            <h3>아직 틀린 문제가 없습니다!</h3>
                            <p>먼저 전체 문제를 풀어보세요.</p>
                            <button class="btn btn-primary" onclick="setQuizMode('all')">전체 문제 풀기</button>
                        </div>
                    `;
                    return;
                }
            } else if (quizMode === 'bookmarked') {
                filteredQuestions = quizQuestions.filter(q => bookmarkedQuestions.has(q.id));
                if (filteredQuestions.length === 0) {
                    document.getElementById('quiz-container').innerHTML = `
                        <div style="text-align: center; padding: 50px;">
                            <h3>북마크한 문제가 없습니다!</h3>
                            <p>문제를 풀면서 북마크를 추가해보세요.</p>
                            <button class="btn btn-primary" onclick="setQuizMode('all')">전체 문제 풀기</button>
                        </div>
                    `;
                    return;
                }
            }
            
            shuffleArray(filteredQuestions);
            window.currentQuizQuestions = filteredQuestions;
            loadQuestion();
        }

        // 문제 로드
        function loadQuestion() {
            const questions = window.currentQuizQuestions || quizQuestions;
            
            if (currentQuestionIndex >= questions.length) {
                showQuizResult();
                return;
            }
            
            const question = questions[currentQuestionIndex];
            const container = document.getElementById('quiz-container');
            
            // 진도 업데이트
            const progress = ((currentQuestionIndex + 1) / questions.length) * 100;
            document.getElementById('quiz-progress').style.width = progress + '%';
            
            container.innerHTML = `
                <div class="question-number">
                    문제 ${currentQuestionIndex + 1} / ${questions.length}
                    ${bookmarkedQuestions.has(question.id) ? '⭐' : ''}
                </div>
                <div class="question">${question.question}</div>
                <div class="options">
                    ${question.options.map((option, index) => `
                        <div class="option" onclick="selectOption(${index})">
                            <input type="radio" name="answer" value="${index}" id="option${index}">
                            <label for="option${index}" style="cursor: pointer; width: 100%;">${option}</label>
                        </div>
                    `).join('')}
                </div>
                <div id="explanation" style="display: none;"></div>
                <div class="quiz-controls">
                    <button class="btn btn-warning" onclick="bookmarkQuestion(${question.id})">
                        ${bookmarkedQuestions.has(question.id) ? '⭐ 북마크 해제' : '☆ 북마크'}
                    </button>
                    <button class="btn btn-secondary" onclick="skipQuestion()" id="skip-btn">건너뛰기</button>
                    <button class="btn btn-primary" onclick="submitAnswer()" id="submit-btn">답안 제출</button>
                    <button class="btn btn-success" onclick="nextQuestion()" id="next-btn" style="display: none;">다음 문제</button>
                </div>
            `;
        }

        // 문제 북마크
        function bookmarkQuestion(questionId) {
            if (bookmarkedQuestions.has(questionId)) {
                bookmarkedQuestions.delete(questionId);
            } else {
                bookmarkedQuestions.add(questionId);
            }
            saveToStorage();
            loadQuestion(); // 화면 새로고침
        }

        // 옵션 선택
        function selectOption(index) {
            document.querySelectorAll('.option').forEach(opt => opt.classList.remove('selected'));
            document.querySelectorAll('.option')[index].classList.add('selected');
            document.getElementById(`option${index}`).checked = true;
        }

        // 답안 제출
        function submitAnswer() {
            const selected = document.querySelector('input[name="answer"]:checked');
            if (!selected) {
                alert('답을 선택해주세요!');
                return;
            }
            
            const selectedIndex = parseInt(selected.value);
            const questions = window.currentQuizQuestions || quizQuestions;
            const question = questions[currentQuestionIndex];
            const isCorrect = selectedIndex === question.correct;
            
            // 정답/오답 표시
            document.querySelectorAll('.option').forEach((opt, index) => {
                opt.onclick = null;
                if (index === question.correct) {
                    opt.classList.add('correct');
                } else if (index === selectedIndex && !isCorrect) {
                    opt.classList.add('incorrect');
                }
            });
            
            // 오답 기록
            if (!isCorrect) {
                incorrectQuestions.add(question.id);
            } else {
                incorrectQuestions.delete(question.id);
            }
            
            // 설명 표시
            const explanationDiv = document.getElementById('explanation');
            explanationDiv.className = 'explanation';
            explanationDiv.style.display = 'block';
            explanationDiv.innerHTML = `
                <h4>${isCorrect ? '✅ 정답입니다!' : '❌ 틀렸습니다.'}</h4>
                <p>${question.explanation}</p>
                <p style="margin-top: 10px; font-size: 14px; color: #7f8c8d;">
                    카테고리: ${getCategoryName(question.category)}
                </p>
            `;
            
            if (isCorrect) score++;
            
            // 답변 기록 저장
            answeredQuestions.push({
                questionId: question.id,
                question: question.question,
                userAnswer: selectedIndex,
                correctAnswer: question.correct,
                correct: isCorrect,
                category: question.category,
                timestamp: new Date().toISOString()
            });
            
            saveToStorage();
            updateStats();
            updateReviewBadge();
            
            // 버튼 상태 변경
            document.getElementById('submit-btn').style.display = 'none';
            document.getElementById('skip-btn').style.display = 'none';
            document.getElementById('next-btn').style.display = 'inline-block';
        }

        // 문제 건너뛰기
        function skipQuestion() {
            const questions = window.currentQuizQuestions || quizQuestions;
            answeredQuestions.push({
                questionId: questions[currentQuestionIndex].id,
                question: questions[currentQuestionIndex].question,
                correct: false,
                skipped: true,
                category: questions[currentQuestionIndex].category,
                timestamp: new Date().toISOString()
            });
            currentQuestionIndex++;
            loadQuestion();
        }

        // 다음 문제
        function nextQuestion() {
            currentQuestionIndex++;
            loadQuestion();
        }

        // 결과 표시
        function showQuizResult() {
            const questions = window.currentQuizQuestions || quizQuestions;
            const container = document.getElementById('quiz-container');
            const percentage = Math.round((score / questions.length) * 100);
            
            container.innerHTML = `
                <div class="score-display">
                    <h2>🎉 테스트 완료!</h2>
                    <h2>${score} / ${questions.length}</h2>
                    <p>정답률: ${percentage}%</p>
                    <p>${percentage >= 70 ? '합격 기준을 통과했습니다!' : '더 연습이 필요합니다.'}</p>
                    <button class="btn btn-primary" onclick="startQuiz()" style="margin-top: 20px;">다시 시작</button>
                    <button class="btn btn-secondary" onclick="showSection('review')" style="margin-top: 20px;">오답 확인</button>
                </div>
            `;
        }

        // 플래시카드 모드 설정
        function setFlashcardMode(mode) {
            flashcardMode = mode;
            document.querySelectorAll('#flashcard .mode-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            currentCardIndex = 0;
            loadFlashcard();
        }

        // 플래시카드 로드
        function loadFlashcard() {
            let filteredTerms = terms;
            
            if (flashcardMode === 'important') {
                filteredTerms = terms.filter(t => t.importance === '필수암기');
            } else if (flashcardMode === 'bookmarked') {
                filteredTerms = terms.filter((t, index) => bookmarkedTerms.has(index));
            }
            
            if (filteredTerms.length === 0) {
                document.getElementById('flashcard-term').textContent = '표시할 카드가 없습니다';
                document.getElementById('flashcard-definition').textContent = '다른 모드를 선택해주세요';
                return;
            }
            
            window.currentFlashcards = filteredTerms;
            const term = filteredTerms[currentCardIndex];
            
            document.getElementById('flashcard-term').textContent = term.term;
            document.getElementById('flashcard-definition').textContent = term.definition;
            document.getElementById('card-importance').textContent = term.importance;
            document.getElementById('card-counter').textContent = `${currentCardIndex + 1} / ${filteredTerms.length}`;
            
            // 카드 앞면 표시
            document.getElementById('card-front').style.display = 'block';
            document.getElementById('card-back').style.display = 'none';
        }

        function flipCard() {
            const front = document.getElementById('card-front');
            const back = document.getElementById('card-back');
            
            if (front.style.display !== 'none') {
                front.style.display = 'none';
                back.style.display = 'block';
            } else {
                front.style.display = 'block';
                back.style.display = 'none';
            }
        }

        function nextCard() {
            const cards = window.currentFlashcards || terms;
            currentCardIndex = (currentCardIndex + 1) % cards.length;
            loadFlashcard();
        }

        function previousCard() {
            const cards = window.currentFlashcards || terms;
            currentCardIndex = currentCardIndex === 0 ? cards.length - 1 : currentCardIndex - 1;
            loadFlashcard();
        }

        function bookmarkCard() {
            const cards = window.currentFlashcards || terms;
            const currentTerm = cards[currentCardIndex];
            const originalIndex = terms.indexOf(currentTerm);
            
            if (bookmarkedTerms.has(originalIndex)) {
                bookmarkedTerms.delete(originalIndex);
            } else {
                bookmarkedTerms.add(originalIndex);
            }
            
            saveToStorage();
            event.target.textContent = bookmarkedTerms.has(originalIndex) ? '⭐ 북마크 해제' : '☆ 북마크';
        }

        // 오답노트 표시
        function displayReviewItems() {
            const container = document.getElementById('review-container');
            container.innerHTML = '';
            
            // 최근 답변 기록과 JSON 데이터 통합
            const recentAnswers = answeredQuestions.slice(-20).reverse();
            
            if (recentAnswers.length === 0 && reviewData["오답노트"].length === 0) {
                container.innerHTML = `
                    <div style="text-align: center; padding: 50px;">
                        <h3>아직 학습 기록이 없습니다!</h3>
                        <p>모의고사를 풀면 여기에 기록이 나타납니다.</p>
                    </div>
                `;
                return;
            }
            
            // 최근 학습 기록 표시
            if (recentAnswers.length > 0) {
                const recentSection = document.createElement('div');
                recentSection.innerHTML = '<h3 style="margin-bottom: 20px;">📝 최근 학습 기록</h3>';
                
                recentAnswers.forEach(answer => {
                    if (answer.skipped) return;
                    
                    const question = quizQuestions.find(q => q.id === answer.questionId);
                    if (!question) return;
                    
                    const reviewItem = document.createElement('div');
                    reviewItem.className = `review-item ${answer.correct ? 'correct' : 'incorrect'}`;
                    
                    reviewItem.innerHTML = `
                        <div class="review-header">
                            <div class="review-status">
                                <span class="review-tag ${answer.correct ? 'tag-correct' : 'tag-incorrect'}">
                                    ${answer.correct ? '정답' : '오답'}
                                </span>
                                <span class="review-tag tag-category">${getCategoryName(question.category)}</span>
                            </div>
                            <button class="btn btn-warning" style="padding: 5px 15px; font-size: 12px;" 
                                    onclick="bookmarkQuestion(${question.id})">
                                ${bookmarkedQuestions.has(question.id) ? '⭐' : '☆'}
                            </button>
                        </div>
                        <div class="review-question">${question.question}</div>
                        <div class="review-options">
                            ${question.options.map((option, index) => `
                                <div class="review-option ${index === answer.userAnswer ? 'user-selected' : ''} 
                                            ${index === question.correct ? 'correct-answer' : ''}">
                                    ${option}
                                </div>
                            `).join('')}
                        </div>
                        <div class="review-explanation">
                            <h4>💡 해설</h4>
                            <p>${question.explanation}</p>
                        </div>
                    `;
                    
                    recentSection.appendChild(reviewItem);
                });
                
                container.appendChild(recentSection);
            }
            
            // 오답노트 JSON 데이터 표시
            if (reviewData["오답노트"].length > 0) {
                const noteSection = document.createElement('div');
                noteSection.innerHTML = '<h3 style="margin: 30px 0 20px;">📚 핵심 오답노트</h3>';
                
                reviewData["오답노트"].forEach(item => {
                    const reviewItem = document.createElement('div');
                    reviewItem.className = 'review-item';
                    reviewItem.style.borderLeft = '5px solid #3498db';
                    
                    reviewItem.innerHTML = `
                        <div class="review-header">
                            <div class="review-status">
                                <span class="review-tag tag-category">${item.카테고리}</span>
                            </div>
                        </div>
                        <div class="review-question">${item.문제}</div>
                        <div class="review-explanation">
                            <h4>✅ 정답</h4>
                            <p>${item.답변}</p>
                        </div>
                    `;
                    
                    noteSection.appendChild(reviewItem);
                });
                
                container.appendChild(noteSection);
            }
        }

        // 리뷰 필터링
        function filterReview(filter) {
            document.querySelectorAll('.review-filters .filter-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // 필터링 로직 구현 (추후 확장 가능)
            displayReviewItems();
        }

        // 통계 업데이트
        function updateStats() {
            const totalAnswered = answeredQuestions.filter(a => !a.skipped).length;
            const correctAnswers = answeredQuestions.filter(a => a.correct).length;
            const correctRate = totalAnswered > 0 ? Math.round((correctAnswers / totalAnswered) * 100) : 0;
            
            document.getElementById('total-solved').textContent = totalAnswered;
            document.getElementById('correct-rate').textContent = correctRate + '%';
            
            // 연속 학습일 계산 (간단한 구현)
            const today = new Date().toDateString();
            const lastStudy = localStorage.getItem('last_study_date');
            let streak = parseInt(localStorage.getItem('study_streak') || '0');
            
            if (lastStudy !== today) {
                streak = lastStudy === new Date(Date.now() - 86400000).toDateString() ? streak + 1 : 1;
                localStorage.setItem('study_streak', streak.toString());
                localStorage.setItem('last_study_date', today);
            }
            
            document.getElementById('study-streak').textContent = streak + '일';
        }

        // 리뷰 배지 업데이트
        function updateReviewBadge() {
            const incorrectCount = incorrectQuestions.size;
            const badge = document.getElementById('review-badge');
            
            if (incorrectCount > 0) {
                badge.textContent = incorrectCount;
                badge.style.display = 'inline-block';
            } else {
                badge.style.display = 'none';
            }
        }

        // 통계 표시
        function displayStats() {
            const totalAnswered = answeredQuestions.filter(a => !a.skipped).length;
            const correctAnswers = answeredQuestions.filter(a => a.correct).length;
            const correctRate = totalAnswered > 0 ? Math.round((correctAnswers / totalAnswered) * 100) : 0;
            
            document.getElementById('stat-total').textContent = totalAnswered;
            document.getElementById('stat-correct').textContent = correctRate + '%';
            
            // 카테고리별 통계 계산
            const categoryStats = {};
            answeredQuestions.forEach(answer => {
                if (!answer.skipped && answer.category) {
                    if (!categoryStats[answer.category]) {
                        categoryStats[answer.category] = { total: 0, correct: 0 };
                    }
                    categoryStats[answer.category].total++;
                    if (answer.correct) {
                        categoryStats[answer.category].correct++;
                    }
                }
            });
            
            // 취약/강점 영역 찾기
            let weakestCategory = '-';
            let strongestCategory = '-';
            let lowestRate = 100;
            let highestRate = 0;
            
            Object.entries(categoryStats).forEach(([category, stats]) => {
                const rate = (stats.correct / stats.total) * 100;
                if (rate < lowestRate) {
                    lowestRate = rate;
                    weakestCategory = getCategoryName(category);
                }
                if (rate > highestRate) {
                    highestRate = rate;
                    strongestCategory = getCategoryName(category);
                }
            });
            
            document.getElementById('stat-weak').textContent = weakestCategory;
            document.getElementById('stat-strong').textContent = strongestCategory;
            
            // 카테고리별 상세 통계 표시
            const categoryStatsContainer = document.getElementById('category-stats');
            categoryStatsContainer.innerHTML = '';
            
            Object.entries(categoryStats).forEach(([category, stats]) => {
                const rate = Math.round((stats.correct / stats.total) * 100);
                const statItem = document.createElement('div');
                statItem.style.marginBottom = '15px';
                
                statItem.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                        <span>${getCategoryName(category)}</span>
                        <span>${stats.correct}/${stats.total} (${rate}%)</span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" style="width: ${rate}%; background: ${rate >= 70 ? '#27ae60' : rate >= 50 ? '#f39c12' : '#e74c3c'};"></div>
                    </div>
                `;
                
                categoryStatsContainer.appendChild(statItem);
            });
        }

        // 배열 섞기 함수
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }
    </script>
</body>
</html>